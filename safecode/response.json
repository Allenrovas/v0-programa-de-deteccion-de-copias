{
    "session_id": "323c8304-f54c-4baa-a6a4-eefec5065d1f",
    "message": "Archivos procesados correctamente",
    "num_files": 3,
    "language": "javascript",
    "result_summary": {
        "session_id": "323c8304-f54c-4baa-a6a4-eefec5065d1f",
        "language": "javascript",
        "num_submissions": 3,
        "num_files_analyzed": 23,
        "similarity_threshold": 0.6,
        "fragment_threshold": 0.7,
        "similarity_results": [
            {
                "submission1": "extracted_-EDD_junio-Proyecto2_201800992-main",
                "submission2": "extracted_-EDD_junio-Proyecto2_201801178-main",
                "max_similarity": 0.817989114278231,
                "is_plagiarism": true,
                "plagiarism_probability": 0.8040902838422685,
                "similar_files": [
                    {
                        "file1": "-EDD_junio-Proyecto2_201800992-main\\js\\BlockChain\\blockChain.js",
                        "file2": "-EDD_junio-Proyecto2_201801178-main\\src\\data_structs\\block.js",
                        "token_similarity": 0.7660278148232484,
                        "ml_similarity": 0.8959310634607047,
                        "combined_similarity": 0.817989114278231,
                        "is_plagiarism": true,
                        "plagiarism_probability": 0.8040902838422685,
                        "fragments": [
                            {
                                "fragment1_start": 0,
                                "fragment1_end": 20,
                                "fragment2_start": 280,
                                "fragment2_end": 300,
                                "similarity": 0.7727474779549475,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                                "code2": "import LinkedList from \"../data_structs/linked_list.js\";\n\nclass _Block{\n    constructor({\n        index,\n        timeStamp,\n        prevHash,\n        rootMerkle,\n        data,\n    }){\n        this.index = index;\n        this.timeStamp = timeStamp;\n        this.prevHash = prevHash;\n        this.rootMerkle = rootMerkle;\n        this.data = data;\n        this.hash = this._genHash();\n        this.nonce = 0;\n        this._proofOfWork();\n    }\n    _proofOfWork(){\n        while(!this.hash.startsWith('00')){\n            this.nonce++;\n            this.hash = this._genHash();\n        }\n    }\n    _genHash(){\n        return Sha256.hash(this.index+this.timeStamp+this.prevHash+this.root+this.nonce);\n    }\n    toString(){\n        return `\n        bloque: ${this.index}\\\\n\n        hash: ${this.hash}\\\\n\n        nonce: ${this.nonce}\\\\n\n        prev: ${this.prevHash}\\\\n\n        rootMerkle: ${this.rootMerkle}\\\\n\n        transacciones:\\\\n\n        ${this.data}\n        timeStamp: ${this.timeStamp}\n        `;\n    }\n}\n\nexport default class BlockChain{\n    constructor(){\n        this.blocks = new LinkedList();\n        this.index = 0;\n    }\n    genNewBlock(timeStamp, root, list){\n        const data = {\n            index: this.index++,\n            timeStamp: timeStamp,\n            prevHash: (this.blocks.isEmpty()) ? this.blocks.end.data.hash : '',\n            rootMerkle: root,\n            data: list,\n        };\n        this.blocks.add(new _Block(data));\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                            },
                            {
                                "fragment1_start": 0,
                                "fragment1_end": 1200,
                                "fragment2_start": 1520,
                                "fragment2_end": 1540,
                                "similarity": 0.9412181204694048,
                                "code1": "\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                                "code2": "import LinkedList from \"../data_structs/linked_list.js\";\n\nclass _Block{\n    constructor({\n        index,\n        timeStamp,\n        prevHash,\n        rootMerkle,\n        data,\n    }){\n        this.index = index;\n        this.timeStamp = timeStamp;\n        this.prevHash = prevHash;\n        this.rootMerkle = rootMerkle;\n        this.data = data;\n        this.hash = this._genHash();\n        this.nonce = 0;\n        this._proofOfWork();\n    }\n    _proofOfWork(){\n        while(!this.hash.startsWith('00')){\n            this.nonce++;\n            this.hash = this._genHash();\n        }\n    }\n    _genHash(){\n        return Sha256.hash(this.index+this.timeStamp+this.prevHash+this.root+this.nonce);\n    }\n    toString(){\n        return `\n        bloque: ${this.index}\\\\n\n        hash: ${this.hash}\\\\n\n        nonce: ${this.nonce}\\\\n\n        prev: ${this.prevHash}\\\\n\n        rootMerkle: ${this.rootMerkle}\\\\n\n        transacciones:\\\\n\n        ${this.data}\n        timeStamp: ${this.timeStamp}\n        `;\n    }\n}\n\nexport default class BlockChain{\n    constructor(){\n        this.blocks = new LinkedList();\n        this.index = 0;\n    }\n    genNewBlock(timeStamp, root, list){\n        const data = {\n            index: this.index++,\n            timeStamp: timeStamp,\n            prevHash: (this.blocks.isEmpty()) ? this.blocks.end.data.hash : '',\n            rootMerkle: root,\n            data: list,\n        };\n        this.blocks.add(new _Block(data));\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                            },
                            {
                                "fragment1_start": 1180,
                                "fragment1_end": 1320,
                                "fragment2_start": 1630,
                                "fragment2_end": 1660,
                                "similarity": 0.9407070962311863,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                                "code2": "import LinkedList from \"../data_structs/linked_list.js\";\n\nclass _Block{\n    constructor({\n        index,\n        timeStamp,\n        prevHash,\n        rootMerkle,\n        data,\n    }){\n        this.index = index;\n        this.timeStamp = timeStamp;\n        this.prevHash = prevHash;\n        this.rootMerkle = rootMerkle;\n        this.data = data;\n        this.hash = this._genHash();\n        this.nonce = 0;\n        this._proofOfWork();\n    }\n    _proofOfWork(){\n        while(!this.hash.startsWith('00')){\n            this.nonce++;\n            this.hash = this._genHash();\n        }\n    }\n    _genHash(){\n        return Sha256.hash(this.index+this.timeStamp+this.prevHash+this.root+this.nonce);\n    }\n    toString(){\n        return `\n        bloque: ${this.index}\\\\n\n        hash: ${this.hash}\\\\n\n        nonce: ${this.nonce}\\\\n\n        prev: ${this.prevHash}\\\\n\n        rootMerkle: ${this.rootMerkle}\\\\n\n        transacciones:\\\\n\n        ${this.data}\n        timeStamp: ${this.timeStamp}\n        `;\n    }\n}\n\nexport default class BlockChain{\n    constructor(){\n        this.blocks = new LinkedList();\n        this.index = 0;\n    }\n    genNewBlock(timeStamp, root, list){\n        const data = {\n            index: this.index++,\n            timeStamp: timeStamp,\n            prevHash: (this.blocks.isEmpty()) ? this.blocks.end.data.hash : '',\n            rootMerkle: root,\n            data: list,\n        };\n        this.blocks.add(new _Block(data));\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                            },
                            {
                                "fragment1_start": 1300,
                                "fragment1_end": 1480,
                                "fragment2_start": 1710,
                                "fragment2_end": 1760,
                                "similarity": 0.8763965607972026,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                                "code2": "import LinkedList from \"../data_structs/linked_list.js\";\n\nclass _Block{\n    constructor({\n        index,\n        timeStamp,\n        prevHash,\n        rootMerkle,\n        data,\n    }){\n        this.index = index;\n        this.timeStamp = timeStamp;\n        this.prevHash = prevHash;\n        this.rootMerkle = rootMerkle;\n        this.data = data;\n        this.hash = this._genHash();\n        this.nonce = 0;\n        this._proofOfWork();\n    }\n    _proofOfWork(){\n        while(!this.hash.startsWith('00')){\n            this.nonce++;\n            this.hash = this._genHash();\n        }\n    }\n    _genHash(){\n        return Sha256.hash(this.index+this.timeStamp+this.prevHash+this.root+this.nonce);\n    }\n    toString(){\n        return `\n        bloque: ${this.index}\\\\n\n        hash: ${this.hash}\\\\n\n        nonce: ${this.nonce}\\\\n\n        prev: ${this.prevHash}\\\\n\n        rootMerkle: ${this.rootMerkle}\\\\n\n        transacciones:\\\\n\n        ${this.data}\n        timeStamp: ${this.timeStamp}\n        `;\n    }\n}\n\nexport default class BlockChain{\n    constructor(){\n        this.blocks = new LinkedList();\n        this.index = 0;\n    }\n    genNewBlock(timeStamp, root, list){\n        const data = {\n            index: this.index++,\n            timeStamp: timeStamp,\n            prevHash: (this.blocks.isEmpty()) ? this.blocks.end.data.hash : '',\n            rootMerkle: root,\n            data: list,\n        };\n        this.blocks.add(new _Block(data));\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                            },
                            {
                                "fragment1_start": 1650,
                                "fragment1_end": 1670,
                                "fragment2_start": 120,
                                "fragment2_end": 140,
                                "similarity": 0.7536076945309456,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                                "code2": "import LinkedList from \"../data_structs/linked_list.js\";\n\nclass _Block{\n    constructor({\n        index,\n        timeStamp,\n        prevHash,\n        rootMerkle,\n        data,\n    }){\n        this.index = index;\n        this.timeStamp = timeStamp;\n        this.prevHash = prevHash;\n        this.rootMerkle = rootMerkle;\n        this.data = data;\n        this.hash = this._genHash();\n        this.nonce = 0;\n        this._proofOfWork();\n    }\n    _proofOfWork(){\n        while(!this.hash.startsWith('00')){\n            this.nonce++;\n            this.hash = this._genHash();\n        }\n    }\n    _genHash(){\n        return Sha256.hash(this.index+this.timeStamp+this.prevHash+this.root+this.nonce);\n    }\n    toString(){\n        return `\n        bloque: ${this.index}\\\\n\n        hash: ${this.hash}\\\\n\n        nonce: ${this.nonce}\\\\n\n        prev: ${this.prevHash}\\\\n\n        rootMerkle: ${this.rootMerkle}\\\\n\n        transacciones:\\\\n\n        ${this.data}\n        timeStamp: ${this.timeStamp}\n        `;\n    }\n}\n\nexport default class BlockChain{\n    constructor(){\n        this.blocks = new LinkedList();\n        this.index = 0;\n    }\n    genNewBlock(timeStamp, root, list){\n        const data = {\n            index: this.index++,\n            timeStamp: timeStamp,\n            prevHash: (this.blocks.isEmpty()) ? this.blocks.end.data.hash : '',\n            rootMerkle: root,\n            data: list,\n        };\n        this.blocks.add(new _Block(data));\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;"
                            },
                            {
                                "fragment1_start": 1750,
                                "fragment1_end": 1790,
                                "fragment2_start": 20,
                                "fragment2_end": 60,
                                "similarity": 0.9765058852081059,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                                "code2": "import LinkedList from \"../data_structs/linked_list.js\";\n\nclass _Block{\n    constructor({\n        index,\n        timeStamp,\n        prevHash,\n        rootMerkle,\n        data,\n    }){\n        this.index = index;\n        this.timeStamp = timeStamp;\n        this.prevHash = prevHash;\n        this.rootMerkle = rootMerkle;\n        this.data = data;\n        this.hash = this._genHash();\n        this.nonce = 0;\n        this._proofOfWork();\n    }\n    _proofOfWork(){\n        while(!this.hash.startsWith('00')){\n            this.nonce++;\n            this.hash = this._genHash();\n        }\n    }\n    _genHash(){\n        return Sha256.hash(this.index+this.timeStamp+this.prevHash+this.root+this.nonce);\n    }\n    toString(){\n        return `\n        bloque: ${this.index}\\\\n\n        hash: ${this.hash}\\\\n\n        nonce: ${this.nonce}\\\\n\n        prev: ${this.prevHash}\\\\n\n        rootMerkle: ${this.rootMerkle}\\\\n\n        transacciones:\\\\n\n        ${this.data}\n        timeStamp: ${this.timeStamp}\n        `;\n    }\n}\n\nexport default class BlockChain{\n    constructor(){\n        this.blocks = new LinkedList();\n        this.index = 0;\n    }\n    genNewBlock(timeStamp, root, list){\n        const data = {\n            index: this.index++,\n            timeStamp: timeStamp,\n            prevHash: (this.blocks.isEmpty()) ? this.blocks.end.data.hash : '',\n            rootMerkle: root,\n            data: list,\n        };\n        this.blocks.add(new _Block(data));\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                            },
                            {
                                "fragment1_start": 1860,
                                "fragment1_end": 1880,
                                "fragment2_start": 230,
                                "fragment2_end": 250,
                                "similarity": 0.7333905011867399,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                                "code2": "import LinkedList from \"../data_structs/linked_list.js\";\n\nclass _Block{\n    constructor({\n        index,\n        timeStamp,\n        prevHash,\n        rootMerkle,\n        data,\n    }){\n        this.index = index;\n        this.timeStamp = timeStamp;\n        this.prevHash = prevHash;\n        this.rootMerkle = rootMerkle;\n        this.data = data;\n        this.hash = this._genHash();\n        this.nonce = 0;\n        this._proofOfWork();\n    }\n    _proofOfWork(){\n        while(!this.hash.startsWith('00')){\n            this.nonce++;\n            this.hash = this._genHash();\n        }\n    }\n    _genHash(){\n        return Sha256.hash(this.index+this.timeStamp+this.prevHash+this.root+this.nonce);\n    }\n    toString(){\n        return `\n        bloque: ${this.index}\\\\n\n        hash: ${this.hash}\\\\n\n        nonce: ${this.nonce}\\\\n\n        prev: ${this.prevHash}\\\\n\n        rootMerkle: ${this.rootMerkle}\\\\n\n        transacciones:\\\\n\n        ${this.data}\n        timeStamp: ${this.timeStamp}\n        `;\n    }\n}\n\nexport default class BlockChain{\n    constructor(){\n        this.blocks = new LinkedList();\n        this.index = 0;\n    }\n    genNewBlock(timeStamp, root, list){\n        const data = {\n            index: this.index++,\n            timeStamp: timeStamp,\n            prevHash: (this.blocks.isEmpty()) ? this.blocks.end.data.hash : '',\n            rootMerkle: root,\n            data: list,\n        };\n        this.blocks.add(new _Block(data));\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }"
                            }
                        ],
                        "ml_fragments": [
                            {
                                "type": "ml_block",
                                "block1": {
                                    "start_line": 0,
                                    "end_line": 50,
                                    "code": "var Sha256 = {}; Sha256.hash = function (msg, utf8encode) { utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode; if (utf8encode) msg = Utf8.encode(msg); var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]; var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]; msg += String.fromCharCode(0x80); var l = msg.length / 4 + 2; var N = Math.ceil(l / 16); var M = new Array(N); for (var i = 0; i < N; i++) { M[i] = new Array(16); for (var j = 0; j < 16; j++) { M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) | (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3)); } } M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14]) M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff; var W = new Array(64); var a, b, c, d, e, f, g, h; for (var i = 0; i < N; i++) { for (var t = 0; t < 16; t++) W[t] = M[i][t]; for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff; a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7]; for (var t = 0; t < 64; t++) { var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t]; var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c); h = g; g = f; f = e; e = (d + T1) & 0xffffffff; d = c; c = b; b = a; a = (T1 + T2) & 0xffffffff; } H[0] = (H[0] + a) & 0xffffffff; H[1] = (H[1] + b) & 0xffffffff; H[2] = (H[2] + c) & 0xffffffff; H[3] = (H[3] + d) & 0xffffffff; H[4] = (H[4] + e) & 0xffffffff; H[5] = (H[5] + f) & 0xffffffff; H[6] = (H[6] + g) & 0xffffffff; H[7] = (H[7] + h) & 0xffffffff; } return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) + Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]); } Sha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); } Sha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); } Sha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); } Sha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); } Sha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); } Sha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); } Sha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); } Sha256.toHexStr = function (n) { var s = \"\", v; for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); } return s; } var Utf8 = {}; Utf8.encode = function (strUni) { var strUtf = strUni.replace( /[\\u0080-\\u07ff]/g, function (c) { var cc = c.charCodeAt(0); return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f); } ); strUtf = strUtf.replace( /[\\u0800-\\uffff]/g, function (c) { var cc = c.charCodeAt(0); return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f); } ); return strUtf; } Utf8.decode = function (strUtf) { var strUni = strUtf.replace( /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g, function (c) { var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f); return String.fromCharCode(cc); } ); strUni = strUni.replace( /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g, function (c) { var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f; return String.fromCharCode(cc); } ); return strUni; } class Bloque { constructor() { this.id = 0; this.timestamp = \"\"; this.nonce = 0 this.preHash = \"\" this.rootMerkle = \"\" this.hash = \"\" } setdataTime = () => { var today = new Date(); var dd = String(today.getDate()).padStart(2, '0'); var mm = String(today.getMonth() + 1).padStart(2, '0'); var yyyy = today.getFullYear(); var nowh = today.toLocaleTimeString('en-US') today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh; return today } crearBloque = (merkleRoot) => { this.rootMerkle = merkleRoot var flag = true; this.timestamp = this.setdataTime() let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot while (flag) { let aux = (cambiarDatos + this.nonce) this.hash = Sha256.hash(aux) if (this.hash.substring(0, 2) == ! \"00\") { this.preHash = this.hash flag = false } this.nonce++ } this.id++ } } class NodoBlock { constructor(idblock, hash, preHash, merkleRoot, data, fecha) { this.idblock = idblock; this.hash = hash; this.preHash = preHash; this.merkleRoot = merkleRoot; this.data = data; this.fecha = fecha; this.siguiente = null; console.log(\"++++++\"+this.data) } } class BlockChain { constructor() { this.raiz = null; this.ultimo = null this.bloque = new Bloque() } insertar = (data,merkleroot ) => { console.log(\"-------------\" + data) this.bloque.crearBloque(merkleroot) let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp) if (this.raiz == null) { this.raiz = this.ultimo = nuevo } else { this.ultimo.siguiente = nuevo this.ultimo = nuevo } } graph = () => { var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\"; var temp = this.raiz var nodes = \"\"; var conexiones = \"\"; var Nnode = 0; while (temp != null) { nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\"; if (temp.siguiente != null) { var auxnum = Nnode + 1; conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\"; } temp = temp.siguiente Nnode++; } codigodot += \" codigodot += nodes + \"\\n\" codigodot += \" codigodot += \"\\n\" + conexiones + \"\\n}\\n}\" var svg = d3.select(' .width(500) .height(200) .renderDot(codigodot) return console.log(codigodot) } } let block = new BlockChain()"
                                },
                                "block2": {
                                    "start_line": 0,
                                    "end_line": 50,
                                    "code": "import LinkedList from \"../data_structs/linked_list.js\"; class _Block{ constructor({ index, timeStamp, prevHash, rootMerkle, data, }){ this.index = index; this.timeStamp = timeStamp; this.prevHash = prevHash; this.rootMerkle = rootMerkle; this.data = data; this.hash = this._genHash(); this.nonce = 0; this._proofOfWork(); } _proofOfWork(){ while(!this.hash.startsWith('00')){ this.nonce++; this.hash = this._genHash(); } } _genHash(){ return Sha256.hash(this.index+this.timeStamp+this.prevHash+this.root+this.nonce); } toString(){ return ` bloque: ${this.index}\\\\n hash: ${this.hash}\\\\n nonce: ${this.nonce}\\\\n prev: ${this.prevHash}\\\\n rootMerkle: ${this.rootMerkle}\\\\n transacciones:\\\\n ${this.data} timeStamp: ${this.timeStamp} `; } } export default class BlockChain{ constructor(){ this.blocks = new LinkedList(); this.index = 0; } genNewBlock(timeStamp, root, list){ const data = { index: this.index++, timeStamp: timeStamp, prevHash: (this.blocks.isEmpty()) ? this.blocks.end.data.hash : '', rootMerkle: root, data: list, }; this.blocks.add(new _Block(data)); } } var Sha256 = {}; Sha256.hash = function (msg, utf8encode) { utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode; if (utf8encode) msg = Utf8.encode(msg); var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]; var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]; msg += String.fromCharCode(0x80); var l = msg.length / 4 + 2; var N = Math.ceil(l / 16); var M = new Array(N); for (var i = 0; i < N; i++) { M[i] = new Array(16); for (var j = 0; j < 16; j++) { M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) | (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3)); } } M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14]) M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff; var W = new Array(64); var a, b, c, d, e, f, g, h; for (var i = 0; i < N; i++) { for (var t = 0; t < 16; t++) W[t] = M[i][t]; for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff; a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7]; for (var t = 0; t < 64; t++) { var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t]; var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c); h = g; g = f; f = e; e = (d + T1) & 0xffffffff; d = c; c = b; b = a; a = (T1 + T2) & 0xffffffff; } H[0] = (H[0] + a) & 0xffffffff; H[1] = (H[1] + b) & 0xffffffff; H[2] = (H[2] + c) & 0xffffffff; H[3] = (H[3] + d) & 0xffffffff; H[4] = (H[4] + e) & 0xffffffff; H[5] = (H[5] + f) & 0xffffffff; H[6] = (H[6] + g) & 0xffffffff; H[7] = (H[7] + h) & 0xffffffff; } return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) + Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]); } Sha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); } Sha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); } Sha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); } Sha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); } Sha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); } Sha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); } Sha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); } Sha256.toHexStr = function (n) { var s = \"\", v; for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); } return s; } var Utf8 = {}; Utf8.encode = function (strUni) { var strUtf = strUni.replace( /[\\u0080-\\u07ff]/g, function (c) { var cc = c.charCodeAt(0); return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f); } ); strUtf = strUtf.replace( /[\\u0800-\\uffff]/g, function (c) { var cc = c.charCodeAt(0); return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f); } ); return strUtf; } Utf8.decode = function (strUtf) { var strUni = strUtf.replace( /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g, function (c) { var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f); return String.fromCharCode(cc); } ); strUni = strUni.replace( /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g, function (c) { var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f; return String.fromCharCode(cc); } ); return strUni; }"
                                },
                                "similarity": 0.8959310634607047,
                                "similarity_details": {
                                    "tfidf": 0.91361488423569,
                                    "char_ngram": 0.9145146556404588,
                                    "word_ngram": 0.7044265089909426,
                                    "embedding": 0.9735496044158936
                                }
                            }
                        ]
                    },
                    {
                        "file1": "-EDD_junio-Proyecto2_201800992-main\\js\\BlockChain\\blockChain.js",
                        "file2": "-EDD_junio-Proyecto2_201801178-main\\src\\data_structs\\merkle.js",
                        "token_similarity": 0.7658276814671913,
                        "ml_similarity": 0.8820938949638769,
                        "combined_similarity": 0.8123341668658655,
                        "is_plagiarism": true,
                        "plagiarism_probability": 0.7970154608336859,
                        "fragments": [
                            {
                                "fragment1_start": 0,
                                "fragment1_end": 250,
                                "fragment2_start": 440,
                                "fragment2_end": 690,
                                "similarity": 1.0000000000000009,
                                "code1": "\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                                "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                            },
                            {
                                "fragment1_start": 230,
                                "fragment1_end": 660,
                                "fragment2_start": 900,
                                "fragment2_end": 1100,
                                "similarity": 1.0000000000000007,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                                "code2": "class _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }"
                            },
                            {
                                "fragment1_start": 640,
                                "fragment1_end": 760,
                                "fragment2_start": 1110,
                                "fragment2_end": 1200,
                                "similarity": 1.0000000000000002,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                                "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                            },
                            {
                                "fragment1_start": 740,
                                "fragment1_end": 990,
                                "fragment2_start": 1260,
                                "fragment2_end": 1430,
                                "similarity": 1.0000000000000007,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                                "code2": "\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                            },
                            {
                                "fragment1_start": 970,
                                "fragment1_end": 990,
                                "fragment2_start": 1450,
                                "fragment2_end": 1470,
                                "similarity": 0.7108814122903837,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                                "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                            },
                            {
                                "fragment1_start": 970,
                                "fragment1_end": 1000,
                                "fragment2_start": 1490,
                                "fragment2_end": 1510,
                                "similarity": 1,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                                "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                            },
                            {
                                "fragment1_start": 980,
                                "fragment1_end": 1140,
                                "fragment2_start": 1530,
                                "fragment2_end": 1580,
                                "similarity": 1.0000000000000007,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                                "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                            },
                            {
                                "fragment1_start": 1120,
                                "fragment1_end": 1270,
                                "fragment2_start": 1590,
                                "fragment2_end": 1710,
                                "similarity": 1.0000000000000009,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                                "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                            },
                            {
                                "fragment1_start": 1250,
                                "fragment1_end": 1280,
                                "fragment2_start": 1800,
                                "fragment2_end": 1830,
                                "similarity": 1,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                                "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                            },
                            {
                                "fragment1_start": 1260,
                                "fragment1_end": 1440,
                                "fragment2_start": 1880,
                                "fragment2_end": 1900,
                                "similarity": 1.0000000000000007,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                                "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }"
                            },
                            {
                                "fragment1_start": 1420,
                                "fragment1_end": 1510,
                                "fragment2_start": 1910,
                                "fragment2_end": 1930,
                                "similarity": 1.0000000000000007,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                                "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                            },
                            {
                                "fragment1_start": 1740,
                                "fragment1_end": 1790,
                                "fragment2_start": 10,
                                "fragment2_end": 30,
                                "similarity": 0.7258866455167113,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                                "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;"
                            },
                            {
                                "fragment1_start": 1800,
                                "fragment1_end": 1830,
                                "fragment2_start": 40,
                                "fragment2_end": 70,
                                "similarity": 0.8471718503999901,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                                "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                            },
                            {
                                "fragment1_start": 1900,
                                "fragment1_end": 1920,
                                "fragment2_start": 350,
                                "fragment2_end": 370,
                                "similarity": 0.716698972693261,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                                "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }"
                            }
                        ],
                        "ml_fragments": [
                            {
                                "type": "ml_block",
                                "block1": {
                                    "start_line": 0,
                                    "end_line": 50,
                                    "code": "var Sha256 = {}; Sha256.hash = function (msg, utf8encode) { utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode; if (utf8encode) msg = Utf8.encode(msg); var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]; var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]; msg += String.fromCharCode(0x80); var l = msg.length / 4 + 2; var N = Math.ceil(l / 16); var M = new Array(N); for (var i = 0; i < N; i++) { M[i] = new Array(16); for (var j = 0; j < 16; j++) { M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) | (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3)); } } M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14]) M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff; var W = new Array(64); var a, b, c, d, e, f, g, h; for (var i = 0; i < N; i++) { for (var t = 0; t < 16; t++) W[t] = M[i][t]; for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff; a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7]; for (var t = 0; t < 64; t++) { var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t]; var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c); h = g; g = f; f = e; e = (d + T1) & 0xffffffff; d = c; c = b; b = a; a = (T1 + T2) & 0xffffffff; } H[0] = (H[0] + a) & 0xffffffff; H[1] = (H[1] + b) & 0xffffffff; H[2] = (H[2] + c) & 0xffffffff; H[3] = (H[3] + d) & 0xffffffff; H[4] = (H[4] + e) & 0xffffffff; H[5] = (H[5] + f) & 0xffffffff; H[6] = (H[6] + g) & 0xffffffff; H[7] = (H[7] + h) & 0xffffffff; } return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) + Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]); } Sha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); } Sha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); } Sha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); } Sha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); } Sha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); } Sha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); } Sha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); } Sha256.toHexStr = function (n) { var s = \"\", v; for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); } return s; } var Utf8 = {}; Utf8.encode = function (strUni) { var strUtf = strUni.replace( /[\\u0080-\\u07ff]/g, function (c) { var cc = c.charCodeAt(0); return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f); } ); strUtf = strUtf.replace( /[\\u0800-\\uffff]/g, function (c) { var cc = c.charCodeAt(0); return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f); } ); return strUtf; } Utf8.decode = function (strUtf) { var strUni = strUtf.replace( /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g, function (c) { var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f); return String.fromCharCode(cc); } ); strUni = strUni.replace( /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g, function (c) { var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f; return String.fromCharCode(cc); } ); return strUni; } class Bloque { constructor() { this.id = 0; this.timestamp = \"\"; this.nonce = 0 this.preHash = \"\" this.rootMerkle = \"\" this.hash = \"\" } setdataTime = () => { var today = new Date(); var dd = String(today.getDate()).padStart(2, '0'); var mm = String(today.getMonth() + 1).padStart(2, '0'); var yyyy = today.getFullYear(); var nowh = today.toLocaleTimeString('en-US') today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh; return today } crearBloque = (merkleRoot) => { this.rootMerkle = merkleRoot var flag = true; this.timestamp = this.setdataTime() let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot while (flag) { let aux = (cambiarDatos + this.nonce) this.hash = Sha256.hash(aux) if (this.hash.substring(0, 2) == ! \"00\") { this.preHash = this.hash flag = false } this.nonce++ } this.id++ } } class NodoBlock { constructor(idblock, hash, preHash, merkleRoot, data, fecha) { this.idblock = idblock; this.hash = hash; this.preHash = preHash; this.merkleRoot = merkleRoot; this.data = data; this.fecha = fecha; this.siguiente = null; console.log(\"++++++\"+this.data) } } class BlockChain { constructor() { this.raiz = null; this.ultimo = null this.bloque = new Bloque() } insertar = (data,merkleroot ) => { console.log(\"-------------\" + data) this.bloque.crearBloque(merkleroot) let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp) if (this.raiz == null) { this.raiz = this.ultimo = nuevo } else { this.ultimo.siguiente = nuevo this.ultimo = nuevo } } graph = () => { var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\"; var temp = this.raiz var nodes = \"\"; var conexiones = \"\"; var Nnode = 0; while (temp != null) { nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\"; if (temp.siguiente != null) { var auxnum = Nnode + 1; conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\"; } temp = temp.siguiente Nnode++; } codigodot += \" codigodot += nodes + \"\\n\" codigodot += \" codigodot += \"\\n\" + conexiones + \"\\n}\\n}\" var svg = d3.select(' .width(500) .height(200) .renderDot(codigodot) return console.log(codigodot) } } let block = new BlockChain()"
                                },
                                "block2": {
                                    "start_line": 0,
                                    "end_line": 50,
                                    "code": "import LinkedList from \"./linked_list.js\"; class _Node{ constructor(data,id){ this.data = data; this.left = this.right = null; this.id = `n${id}`; } } export default class MerkleTree{ constructor(){ this.root = null; this.dataBlocks = null; this.curr_block = null; this.junkBlocks = null; this.id = 0; } _fillDataBlocks(){ let n = 1; let powerOf2 = Math.pow(2,n); while(powerOf2 < this.dataBlocks.len){ n++; powerOf2 = Math.pow(2,n); } this.junkBlocks = new LinkedList(); for (let i = this.dataBlocks.len; i < powerOf2; i++) { this.junkBlocks.add(i*100); } return n; } genTree(list){ if(list.isEmpty()){ this.dataBlocks = list; this.curr_block = this.dataBlocks.head; const exp = this._fillDataBlocks(); this.root = new _Node(null, this.id++); this._genTreeRec(this.root, exp); this._genHash(this.root); } } _genTreeRec(root, exp){ if(exp > 0){ root.left = new _Node(null, this.id++); root.right = new _Node(null, this.id++); this._genTreeRec(root.left, exp-1); this._genTreeRec(root.right, exp-1); } else{ root.data = Sha256.hash(this.curr_block.data.toString()); if(this.curr_block.next){ this.curr_block = this.curr_block.next; } else{ this.curr_block = this.junkBlocks.head; } } } _genHash(root){ if(root == null){ return; } this._genHash(root.left); this._genHash(root.right); if(!root.data){ root.data = Sha256.hash(root.left.data + root.right.data); } } } var Sha256 = {}; Sha256.hash = function (msg, utf8encode) { utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode; if (utf8encode) msg = Utf8.encode(msg); var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]; var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]; msg += String.fromCharCode(0x80); var l = msg.length / 4 + 2; var N = Math.ceil(l / 16); var M = new Array(N); for (var i = 0; i < N; i++) { M[i] = new Array(16); for (var j = 0; j < 16; j++) { M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) | (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3)); } } M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14]) M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff; var W = new Array(64); var a, b, c, d, e, f, g, h; for (var i = 0; i < N; i++) { for (var t = 0; t < 16; t++) W[t] = M[i][t]; for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff; a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7]; for (var t = 0; t < 64; t++) { var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t]; var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c); h = g; g = f; f = e; e = (d + T1) & 0xffffffff; d = c; c = b; b = a; a = (T1 + T2) & 0xffffffff; } H[0] = (H[0] + a) & 0xffffffff; H[1] = (H[1] + b) & 0xffffffff; H[2] = (H[2] + c) & 0xffffffff; H[3] = (H[3] + d) & 0xffffffff; H[4] = (H[4] + e) & 0xffffffff; H[5] = (H[5] + f) & 0xffffffff; H[6] = (H[6] + g) & 0xffffffff; H[7] = (H[7] + h) & 0xffffffff; } return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) + Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]); } Sha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); } Sha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); } Sha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); } Sha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); } Sha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); } Sha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); } Sha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); } Sha256.toHexStr = function (n) { var s = \"\", v; for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); } return s; } var Utf8 = {}; Utf8.encode = function (strUni) { var strUtf = strUni.replace( /[\\u0080-\\u07ff]/g, function (c) { var cc = c.charCodeAt(0); return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f); } ); strUtf = strUtf.replace( /[\\u0800-\\uffff]/g, function (c) { var cc = c.charCodeAt(0); return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f); } ); return strUtf; } Utf8.decode = function (strUtf) { var strUni = strUtf.replace( /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g, function (c) { var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f); return String.fromCharCode(cc); } ); strUni = strUni.replace( /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g, function (c) { var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f; return String.fromCharCode(cc); } ); return strUni; }"
                                },
                                "similarity": 0.8820938949638769,
                                "similarity_details": {
                                    "tfidf": 0.9089436926233514,
                                    "char_ngram": 0.8970035633389773,
                                    "word_ngram": 0.6752840782740173,
                                    "embedding": 0.9646190404891968
                                }
                            }
                        ]
                    },
                    {
                        "file1": "-EDD_junio-Proyecto2_201800992-main\\js\\Arboles\\arbolMerkle.js",
                        "file2": "-EDD_junio-Proyecto2_201801178-main\\src\\data_structs\\merkle.js",
                        "token_similarity": 0.681456263861494,
                        "ml_similarity": 0.7826109736901622,
                        "combined_similarity": 0.7219181477929613,
                        "is_plagiarism": false,
                        "plagiarism_probability": 0.6953369351452039,
                        "fragments": [
                            {
                                "fragment1_start": 0,
                                "fragment1_end": 250,
                                "fragment2_start": 440,
                                "fragment2_end": 690,
                                "similarity": 1.0000000000000009,
                                "code1": "\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                                "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                            },
                            {
                                "fragment1_start": 230,
                                "fragment1_end": 660,
                                "fragment2_start": 900,
                                "fragment2_end": 1100,
                                "similarity": 1.0000000000000007,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                                "code2": "class _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }"
                            },
                            {
                                "fragment1_start": 640,
                                "fragment1_end": 760,
                                "fragment2_start": 1110,
                                "fragment2_end": 1200,
                                "similarity": 1.0000000000000002,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                                "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                            },
                            {
                                "fragment1_start": 740,
                                "fragment1_end": 990,
                                "fragment2_start": 1260,
                                "fragment2_end": 1430,
                                "similarity": 1.0000000000000007,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                                "code2": "\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                            },
                            {
                                "fragment1_start": 970,
                                "fragment1_end": 990,
                                "fragment2_start": 1450,
                                "fragment2_end": 1470,
                                "similarity": 0.7108814122903837,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                                "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                            },
                            {
                                "fragment1_start": 970,
                                "fragment1_end": 1000,
                                "fragment2_start": 1490,
                                "fragment2_end": 1510,
                                "similarity": 1,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                                "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                            },
                            {
                                "fragment1_start": 980,
                                "fragment1_end": 1140,
                                "fragment2_start": 1530,
                                "fragment2_end": 1580,
                                "similarity": 1.0000000000000007,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                                "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                            },
                            {
                                "fragment1_start": 1120,
                                "fragment1_end": 1270,
                                "fragment2_start": 1590,
                                "fragment2_end": 1710,
                                "similarity": 1.0000000000000009,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                                "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                            },
                            {
                                "fragment1_start": 1250,
                                "fragment1_end": 1280,
                                "fragment2_start": 1800,
                                "fragment2_end": 1830,
                                "similarity": 1,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                                "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                            },
                            {
                                "fragment1_start": 1260,
                                "fragment1_end": 1440,
                                "fragment2_start": 1880,
                                "fragment2_end": 1900,
                                "similarity": 1.0000000000000007,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                                "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }"
                            },
                            {
                                "fragment1_start": 1420,
                                "fragment1_end": 1490,
                                "fragment2_start": 1910,
                                "fragment2_end": 1930,
                                "similarity": 1.0000000000000007,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                                "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                            },
                            {
                                "fragment1_start": 1890,
                                "fragment1_end": 1920,
                                "fragment2_start": 0,
                                "fragment2_end": 30,
                                "similarity": 0.7493284865824371,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                                "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                            },
                            {
                                "fragment1_start": 2490,
                                "fragment1_end": 2510,
                                "fragment2_start": 390,
                                "fragment2_end": 410,
                                "similarity": 0.7149783475176564,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                                "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                            }
                        ],
                        "ml_fragments": [
                            {
                                "type": "ml_block",
                                "block1": {
                                    "start_line": 0,
                                    "end_line": 50,
                                    "code": "var Sha256 = {}; Sha256.hash = function (msg, utf8encode) { utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode; if (utf8encode) msg = Utf8.encode(msg); var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]; var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]; msg += String.fromCharCode(0x80); var l = msg.length / 4 + 2; var N = Math.ceil(l / 16); var M = new Array(N); for (var i = 0; i < N; i++) { M[i] = new Array(16); for (var j = 0; j < 16; j++) { M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) | (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3)); } } M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14]) M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff; var W = new Array(64); var a, b, c, d, e, f, g, h; for (var i = 0; i < N; i++) { for (var t = 0; t < 16; t++) W[t] = M[i][t]; for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff; a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7]; for (var t = 0; t < 64; t++) { var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t]; var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c); h = g; g = f; f = e; e = (d + T1) & 0xffffffff; d = c; c = b; b = a; a = (T1 + T2) & 0xffffffff; } H[0] = (H[0] + a) & 0xffffffff; H[1] = (H[1] + b) & 0xffffffff; H[2] = (H[2] + c) & 0xffffffff; H[3] = (H[3] + d) & 0xffffffff; H[4] = (H[4] + e) & 0xffffffff; H[5] = (H[5] + f) & 0xffffffff; H[6] = (H[6] + g) & 0xffffffff; H[7] = (H[7] + h) & 0xffffffff; } return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) + Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]); } Sha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); } Sha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); } Sha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); } Sha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); } Sha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); } Sha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); } Sha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); } Sha256.toHexStr = function (n) { var s = \"\", v; for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); } return s; } var Utf8 = {}; Utf8.encode = function (strUni) { var strUtf = strUni.replace( /[\\u0080-\\u07ff]/g, function (c) { var cc = c.charCodeAt(0); return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f); } ); strUtf = strUtf.replace( /[\\u0800-\\uffff]/g, function (c) { var cc = c.charCodeAt(0); return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f); } ); return strUtf; } Utf8.decode = function (strUtf) { var strUni = strUtf.replace( /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g, function (c) { var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f); return String.fromCharCode(cc); } ); strUni = strUni.replace( /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g, function (c) { var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f; return String.fromCharCode(cc); } ); return strUni; } class NodoListaTemporal { constructor(datTemporal) { this.datTemporal = datTemporal this.siguiente = null this.anterior = null } } var contadorglobal = 0 var salida = \"\" class ListaTemporal { constructor() { this.cabeza = null this.cola = null this.size = 0 } insertLista(dato) { let nodo = new NodoListaTemporal(dato); if (this.cabeza == null) { this.cabeza = nodo; this.cola = nodo; this.size++; } else if (this.cabeza != null) { let aux = this.cabeza; while (aux != this.cola) { aux = aux.siguiente; } aux.siguiente = nodo; nodo.anterior = aux this.cola = nodo; this.size++; } } eliminarLista(dato) { let nodo = this.cabeza if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) { this.cabeza = null this.cola = null this.size = 0 return } while (nodo.datTemporal != dato && nodo != this.cola) { nodo = nodo.siguiente } if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) { let tmp = nodo.siguiente this.cabeza = tmp tmp.anterior = null nodo.siguiente = null this.size-- return } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) { let tmp = nodo.siguiente tmp.anterior = nodo.anterior nodo.anterior.siguiente = tmp nodo.siguiente = null nodo.anterior = null this.size-- return } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) { let tmp = nodo.anterior this.cola = tmp tmp.siguiente = null nodo.anterior = null this.size-- return } if (nodo == null) { console.log(\"No se encontro el dato a eliminar\") return } } } var recarga = [] class Nodo { constructor(dato, izquierda, derecha, nodohijo) { this.dato = dato this.hash = null this.id = 0 this.nodohijo = nodohijo this.izquierda = izquierda this.derecha = derecha } } class MerkleTree { constructor() { this.raiz = null } insertar(dato) { let nodo = new Nodo(dato, null, null, true) if (this.raiz == null) { let listatmp = new ListaTemporal() listatmp.insertLista(nodo) listatmp.insertLista(new Nodo(-1, null, null, true)) this.construirArbol(listatmp) } else { let listatmp = this.ObtenerLista() listatmp.insertLista(nodo) this.construirArbol(listatmp) } this.hashing() contadorglobal = 0 } ObtenerLista() { let listatmp = new ListaTemporal() this.obtenerlista(listatmp, this.raiz.izquierda) this.obtenerlista(listatmp, this.raiz.derecha) return listatmp } obtenerlista(lista, nodo) { if (nodo != null) { this.obtenerlista(lista, nodo.izquierda) if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) { lista.insertLista(nodo) } this.obtenerlista(lista, nodo.derecha) } } construirArbol(lista) { let tamanio = new Float64Array(lista.size) let cant = 1 let operacion = tamanio.length / 2 while (operacion > 1) { cant++ operacion = operacion / 2 } let vectorTotal = new Float64Array(cant) let totalnodos = Math.pow(2, vectorTotal.length) while (lista.size < Math.floor(totalnodos)) { lista.insertLista(new Nodo(-1, null, null, true)) } while (lista.size > 1) { let primero = lista.cabeza let segundo = primero.siguiente lista.eliminarLista(primero.datTemporal) lista.eliminarLista(segundo.datTemporal) let nodo1 = primero.datTemporal nodo1.id = contadorglobal + 1 let nodo2 = segundo.datTemporal nodo2.id = contadorglobal + 2 let suma = nodo1.dato + nodo2.dato let nuevo = new Nodo(suma, nodo1, nodo2, false) nuevo.id = contadorglobal lista.insertLista(nuevo) contadorglobal = contadorglobal + 3 } this.raiz = lista.cabeza.datTemporal } hashing() { if (this.raiz == null) { console.log(\"No existe arbol\") return } this.subHashing(this.raiz) } subHashing(nodo) { if (nodo != null) { let hasheo = Sha256.hash(String(nodo.dato)) nodo.hash = hasheo this.subHashing(nodo.izquierda) this.subHashing(nodo.derecha) } } imprimiendo() { if (this.raiz == null) { console.log(\"No existe arbol\") return } this.imprimir(this.raiz) } imprimir(nodo) { if (nodo != null) { console.log(nodo.dato + \" Es el dato\") console.log(nodo.hash + \" Es el Hash\") this.imprimir(nodo.izquierda) this.imprimir(nodo.derecha) } } preOrden(nodo, vector) { if (nodo != null) { vector.push(nodo.dato) this.preOrden(nodo.izquierda, vector) this.preOrden(nodo.derecha, vector) } return vector } graficar(valorBuscar) { salida = \"\" if (this.raiz == null) { console.log(\"No hay nada aun\") return } let nodo = this.raiz let contador = 0 salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\" this.graficando(nodo, valorBuscar) salida += \"}\" contador = 0 d3.select(' .width(750) .height(400) .renderDot(salida) return console.log(salida) } graficando(nodo, valorBuscar) { if (nodo != null) { if (valorBuscar == nodo.dato) { salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\" \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\" } else { salida += \"node\" + nodo.id + \" [label = \\\" \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\" } if (nodo.derecha != null) { salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\" } if (nodo.izquierda != null) { salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\" } if (nodo.izquierda != null) { this.graficando(nodo.izquierda, valorBuscar) } if (nodo.derecha != null) { this.graficando(nodo.derecha, valorBuscar) } } } getMerkleRoot() { return this.raiz.hash } } let Transacciones = new MerkleTree() Transacciones.graficar(0)"
                                },
                                "block2": {
                                    "start_line": 0,
                                    "end_line": 50,
                                    "code": "import LinkedList from \"./linked_list.js\"; class _Node{ constructor(data,id){ this.data = data; this.left = this.right = null; this.id = `n${id}`; } } export default class MerkleTree{ constructor(){ this.root = null; this.dataBlocks = null; this.curr_block = null; this.junkBlocks = null; this.id = 0; } _fillDataBlocks(){ let n = 1; let powerOf2 = Math.pow(2,n); while(powerOf2 < this.dataBlocks.len){ n++; powerOf2 = Math.pow(2,n); } this.junkBlocks = new LinkedList(); for (let i = this.dataBlocks.len; i < powerOf2; i++) { this.junkBlocks.add(i*100); } return n; } genTree(list){ if(list.isEmpty()){ this.dataBlocks = list; this.curr_block = this.dataBlocks.head; const exp = this._fillDataBlocks(); this.root = new _Node(null, this.id++); this._genTreeRec(this.root, exp); this._genHash(this.root); } } _genTreeRec(root, exp){ if(exp > 0){ root.left = new _Node(null, this.id++); root.right = new _Node(null, this.id++); this._genTreeRec(root.left, exp-1); this._genTreeRec(root.right, exp-1); } else{ root.data = Sha256.hash(this.curr_block.data.toString()); if(this.curr_block.next){ this.curr_block = this.curr_block.next; } else{ this.curr_block = this.junkBlocks.head; } } } _genHash(root){ if(root == null){ return; } this._genHash(root.left); this._genHash(root.right); if(!root.data){ root.data = Sha256.hash(root.left.data + root.right.data); } } } var Sha256 = {}; Sha256.hash = function (msg, utf8encode) { utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode; if (utf8encode) msg = Utf8.encode(msg); var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]; var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]; msg += String.fromCharCode(0x80); var l = msg.length / 4 + 2; var N = Math.ceil(l / 16); var M = new Array(N); for (var i = 0; i < N; i++) { M[i] = new Array(16); for (var j = 0; j < 16; j++) { M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) | (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3)); } } M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14]) M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff; var W = new Array(64); var a, b, c, d, e, f, g, h; for (var i = 0; i < N; i++) { for (var t = 0; t < 16; t++) W[t] = M[i][t]; for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff; a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7]; for (var t = 0; t < 64; t++) { var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t]; var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c); h = g; g = f; f = e; e = (d + T1) & 0xffffffff; d = c; c = b; b = a; a = (T1 + T2) & 0xffffffff; } H[0] = (H[0] + a) & 0xffffffff; H[1] = (H[1] + b) & 0xffffffff; H[2] = (H[2] + c) & 0xffffffff; H[3] = (H[3] + d) & 0xffffffff; H[4] = (H[4] + e) & 0xffffffff; H[5] = (H[5] + f) & 0xffffffff; H[6] = (H[6] + g) & 0xffffffff; H[7] = (H[7] + h) & 0xffffffff; } return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) + Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]); } Sha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); } Sha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); } Sha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); } Sha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); } Sha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); } Sha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); } Sha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); } Sha256.toHexStr = function (n) { var s = \"\", v; for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); } return s; } var Utf8 = {}; Utf8.encode = function (strUni) { var strUtf = strUni.replace( /[\\u0080-\\u07ff]/g, function (c) { var cc = c.charCodeAt(0); return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f); } ); strUtf = strUtf.replace( /[\\u0800-\\uffff]/g, function (c) { var cc = c.charCodeAt(0); return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f); } ); return strUtf; } Utf8.decode = function (strUtf) { var strUni = strUtf.replace( /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g, function (c) { var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f); return String.fromCharCode(cc); } ); strUni = strUni.replace( /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g, function (c) { var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f; return String.fromCharCode(cc); } ); return strUni; }"
                                },
                                "similarity": 0.7826109736901622,
                                "similarity_details": {
                                    "tfidf": 0.8135298074469223,
                                    "char_ngram": 0.70211477395347,
                                    "word_ngram": 0.46817214646738037,
                                    "embedding": 0.9646190404891968
                                }
                            }
                        ]
                    },
                    {
                        "file1": "-EDD_junio-Proyecto2_201800992-main\\js\\Arboles\\arbolMerkle.js",
                        "file2": "-EDD_junio-Proyecto2_201801178-main\\src\\data_structs\\block.js",
                        "token_similarity": 0.6657556641443445,
                        "ml_similarity": 0.7832133332332992,
                        "combined_similarity": 0.7127387317799264,
                        "is_plagiarism": false,
                        "plagiarism_probability": 0.6860685048265538,
                        "fragments": [
                            {
                                "fragment1_start": 0,
                                "fragment1_end": 20,
                                "fragment2_start": 280,
                                "fragment2_end": 300,
                                "similarity": 0.7727474779549475,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                                "code2": "import LinkedList from \"../data_structs/linked_list.js\";\n\nclass _Block{\n    constructor({\n        index,\n        timeStamp,\n        prevHash,\n        rootMerkle,\n        data,\n    }){\n        this.index = index;\n        this.timeStamp = timeStamp;\n        this.prevHash = prevHash;\n        this.rootMerkle = rootMerkle;\n        this.data = data;\n        this.hash = this._genHash();\n        this.nonce = 0;\n        this._proofOfWork();\n    }\n    _proofOfWork(){\n        while(!this.hash.startsWith('00')){\n            this.nonce++;\n            this.hash = this._genHash();\n        }\n    }\n    _genHash(){\n        return Sha256.hash(this.index+this.timeStamp+this.prevHash+this.root+this.nonce);\n    }\n    toString(){\n        return `\n        bloque: ${this.index}\\\\n\n        hash: ${this.hash}\\\\n\n        nonce: ${this.nonce}\\\\n\n        prev: ${this.prevHash}\\\\n\n        rootMerkle: ${this.rootMerkle}\\\\n\n        transacciones:\\\\n\n        ${this.data}\n        timeStamp: ${this.timeStamp}\n        `;\n    }\n}\n\nexport default class BlockChain{\n    constructor(){\n        this.blocks = new LinkedList();\n        this.index = 0;\n    }\n    genNewBlock(timeStamp, root, list){\n        const data = {\n            index: this.index++,\n            timeStamp: timeStamp,\n            prevHash: (this.blocks.isEmpty()) ? this.blocks.end.data.hash : '',\n            rootMerkle: root,\n            data: list,\n        };\n        this.blocks.add(new _Block(data));\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                            },
                            {
                                "fragment1_start": 0,
                                "fragment1_end": 1200,
                                "fragment2_start": 1520,
                                "fragment2_end": 1540,
                                "similarity": 0.9412181204694048,
                                "code1": "\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                                "code2": "import LinkedList from \"../data_structs/linked_list.js\";\n\nclass _Block{\n    constructor({\n        index,\n        timeStamp,\n        prevHash,\n        rootMerkle,\n        data,\n    }){\n        this.index = index;\n        this.timeStamp = timeStamp;\n        this.prevHash = prevHash;\n        this.rootMerkle = rootMerkle;\n        this.data = data;\n        this.hash = this._genHash();\n        this.nonce = 0;\n        this._proofOfWork();\n    }\n    _proofOfWork(){\n        while(!this.hash.startsWith('00')){\n            this.nonce++;\n            this.hash = this._genHash();\n        }\n    }\n    _genHash(){\n        return Sha256.hash(this.index+this.timeStamp+this.prevHash+this.root+this.nonce);\n    }\n    toString(){\n        return `\n        bloque: ${this.index}\\\\n\n        hash: ${this.hash}\\\\n\n        nonce: ${this.nonce}\\\\n\n        prev: ${this.prevHash}\\\\n\n        rootMerkle: ${this.rootMerkle}\\\\n\n        transacciones:\\\\n\n        ${this.data}\n        timeStamp: ${this.timeStamp}\n        `;\n    }\n}\n\nexport default class BlockChain{\n    constructor(){\n        this.blocks = new LinkedList();\n        this.index = 0;\n    }\n    genNewBlock(timeStamp, root, list){\n        const data = {\n            index: this.index++,\n            timeStamp: timeStamp,\n            prevHash: (this.blocks.isEmpty()) ? this.blocks.end.data.hash : '',\n            rootMerkle: root,\n            data: list,\n        };\n        this.blocks.add(new _Block(data));\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                            },
                            {
                                "fragment1_start": 1180,
                                "fragment1_end": 1320,
                                "fragment2_start": 1630,
                                "fragment2_end": 1660,
                                "similarity": 0.9407070962311863,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                                "code2": "import LinkedList from \"../data_structs/linked_list.js\";\n\nclass _Block{\n    constructor({\n        index,\n        timeStamp,\n        prevHash,\n        rootMerkle,\n        data,\n    }){\n        this.index = index;\n        this.timeStamp = timeStamp;\n        this.prevHash = prevHash;\n        this.rootMerkle = rootMerkle;\n        this.data = data;\n        this.hash = this._genHash();\n        this.nonce = 0;\n        this._proofOfWork();\n    }\n    _proofOfWork(){\n        while(!this.hash.startsWith('00')){\n            this.nonce++;\n            this.hash = this._genHash();\n        }\n    }\n    _genHash(){\n        return Sha256.hash(this.index+this.timeStamp+this.prevHash+this.root+this.nonce);\n    }\n    toString(){\n        return `\n        bloque: ${this.index}\\\\n\n        hash: ${this.hash}\\\\n\n        nonce: ${this.nonce}\\\\n\n        prev: ${this.prevHash}\\\\n\n        rootMerkle: ${this.rootMerkle}\\\\n\n        transacciones:\\\\n\n        ${this.data}\n        timeStamp: ${this.timeStamp}\n        `;\n    }\n}\n\nexport default class BlockChain{\n    constructor(){\n        this.blocks = new LinkedList();\n        this.index = 0;\n    }\n    genNewBlock(timeStamp, root, list){\n        const data = {\n            index: this.index++,\n            timeStamp: timeStamp,\n            prevHash: (this.blocks.isEmpty()) ? this.blocks.end.data.hash : '',\n            rootMerkle: root,\n            data: list,\n        };\n        this.blocks.add(new _Block(data));\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                            },
                            {
                                "fragment1_start": 1300,
                                "fragment1_end": 1480,
                                "fragment2_start": 1710,
                                "fragment2_end": 1760,
                                "similarity": 0.8763965607972026,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                                "code2": "import LinkedList from \"../data_structs/linked_list.js\";\n\nclass _Block{\n    constructor({\n        index,\n        timeStamp,\n        prevHash,\n        rootMerkle,\n        data,\n    }){\n        this.index = index;\n        this.timeStamp = timeStamp;\n        this.prevHash = prevHash;\n        this.rootMerkle = rootMerkle;\n        this.data = data;\n        this.hash = this._genHash();\n        this.nonce = 0;\n        this._proofOfWork();\n    }\n    _proofOfWork(){\n        while(!this.hash.startsWith('00')){\n            this.nonce++;\n            this.hash = this._genHash();\n        }\n    }\n    _genHash(){\n        return Sha256.hash(this.index+this.timeStamp+this.prevHash+this.root+this.nonce);\n    }\n    toString(){\n        return `\n        bloque: ${this.index}\\\\n\n        hash: ${this.hash}\\\\n\n        nonce: ${this.nonce}\\\\n\n        prev: ${this.prevHash}\\\\n\n        rootMerkle: ${this.rootMerkle}\\\\n\n        transacciones:\\\\n\n        ${this.data}\n        timeStamp: ${this.timeStamp}\n        `;\n    }\n}\n\nexport default class BlockChain{\n    constructor(){\n        this.blocks = new LinkedList();\n        this.index = 0;\n    }\n    genNewBlock(timeStamp, root, list){\n        const data = {\n            index: this.index++,\n            timeStamp: timeStamp,\n            prevHash: (this.blocks.isEmpty()) ? this.blocks.end.data.hash : '',\n            rootMerkle: root,\n            data: list,\n        };\n        this.blocks.add(new _Block(data));\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                            },
                            {
                                "fragment1_start": 1570,
                                "fragment1_end": 1590,
                                "fragment2_start": 20,
                                "fragment2_end": 60,
                                "similarity": 0.7881012364506065,
                                "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                                "code2": "import LinkedList from \"../data_structs/linked_list.js\";\n\nclass _Block{\n    constructor({\n        index,\n        timeStamp,\n        prevHash,\n        rootMerkle,\n        data,\n    }){\n        this.index = index;\n        this.timeStamp = timeStamp;\n        this.prevHash = prevHash;\n        this.rootMerkle = rootMerkle;\n        this.data = data;\n        this.hash = this._genHash();\n        this.nonce = 0;\n        this._proofOfWork();\n    }\n    _proofOfWork(){\n        while(!this.hash.startsWith('00')){\n            this.nonce++;\n            this.hash = this._genHash();\n        }\n    }\n    _genHash(){\n        return Sha256.hash(this.index+this.timeStamp+this.prevHash+this.root+this.nonce);\n    }\n    toString(){\n        return `\n        bloque: ${this.index}\\\\n\n        hash: ${this.hash}\\\\n\n        nonce: ${this.nonce}\\\\n\n        prev: ${this.prevHash}\\\\n\n        rootMerkle: ${this.rootMerkle}\\\\n\n        transacciones:\\\\n\n        ${this.data}\n        timeStamp: ${this.timeStamp}\n        `;\n    }\n}\n\nexport default class BlockChain{\n    constructor(){\n        this.blocks = new LinkedList();\n        this.index = 0;\n    }\n    genNewBlock(timeStamp, root, list){\n        const data = {\n            index: this.index++,\n            timeStamp: timeStamp,\n            prevHash: (this.blocks.isEmpty()) ? this.blocks.end.data.hash : '',\n            rootMerkle: root,\n            data: list,\n        };\n        this.blocks.add(new _Block(data));\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                            }
                        ],
                        "ml_fragments": [
                            {
                                "type": "ml_block",
                                "block1": {
                                    "start_line": 0,
                                    "end_line": 50,
                                    "code": "var Sha256 = {}; Sha256.hash = function (msg, utf8encode) { utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode; if (utf8encode) msg = Utf8.encode(msg); var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]; var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]; msg += String.fromCharCode(0x80); var l = msg.length / 4 + 2; var N = Math.ceil(l / 16); var M = new Array(N); for (var i = 0; i < N; i++) { M[i] = new Array(16); for (var j = 0; j < 16; j++) { M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) | (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3)); } } M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14]) M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff; var W = new Array(64); var a, b, c, d, e, f, g, h; for (var i = 0; i < N; i++) { for (var t = 0; t < 16; t++) W[t] = M[i][t]; for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff; a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7]; for (var t = 0; t < 64; t++) { var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t]; var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c); h = g; g = f; f = e; e = (d + T1) & 0xffffffff; d = c; c = b; b = a; a = (T1 + T2) & 0xffffffff; } H[0] = (H[0] + a) & 0xffffffff; H[1] = (H[1] + b) & 0xffffffff; H[2] = (H[2] + c) & 0xffffffff; H[3] = (H[3] + d) & 0xffffffff; H[4] = (H[4] + e) & 0xffffffff; H[5] = (H[5] + f) & 0xffffffff; H[6] = (H[6] + g) & 0xffffffff; H[7] = (H[7] + h) & 0xffffffff; } return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) + Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]); } Sha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); } Sha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); } Sha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); } Sha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); } Sha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); } Sha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); } Sha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); } Sha256.toHexStr = function (n) { var s = \"\", v; for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); } return s; } var Utf8 = {}; Utf8.encode = function (strUni) { var strUtf = strUni.replace( /[\\u0080-\\u07ff]/g, function (c) { var cc = c.charCodeAt(0); return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f); } ); strUtf = strUtf.replace( /[\\u0800-\\uffff]/g, function (c) { var cc = c.charCodeAt(0); return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f); } ); return strUtf; } Utf8.decode = function (strUtf) { var strUni = strUtf.replace( /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g, function (c) { var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f); return String.fromCharCode(cc); } ); strUni = strUni.replace( /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g, function (c) { var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f; return String.fromCharCode(cc); } ); return strUni; } class NodoListaTemporal { constructor(datTemporal) { this.datTemporal = datTemporal this.siguiente = null this.anterior = null } } var contadorglobal = 0 var salida = \"\" class ListaTemporal { constructor() { this.cabeza = null this.cola = null this.size = 0 } insertLista(dato) { let nodo = new NodoListaTemporal(dato); if (this.cabeza == null) { this.cabeza = nodo; this.cola = nodo; this.size++; } else if (this.cabeza != null) { let aux = this.cabeza; while (aux != this.cola) { aux = aux.siguiente; } aux.siguiente = nodo; nodo.anterior = aux this.cola = nodo; this.size++; } } eliminarLista(dato) { let nodo = this.cabeza if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) { this.cabeza = null this.cola = null this.size = 0 return } while (nodo.datTemporal != dato && nodo != this.cola) { nodo = nodo.siguiente } if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) { let tmp = nodo.siguiente this.cabeza = tmp tmp.anterior = null nodo.siguiente = null this.size-- return } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) { let tmp = nodo.siguiente tmp.anterior = nodo.anterior nodo.anterior.siguiente = tmp nodo.siguiente = null nodo.anterior = null this.size-- return } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) { let tmp = nodo.anterior this.cola = tmp tmp.siguiente = null nodo.anterior = null this.size-- return } if (nodo == null) { console.log(\"No se encontro el dato a eliminar\") return } } } var recarga = [] class Nodo { constructor(dato, izquierda, derecha, nodohijo) { this.dato = dato this.hash = null this.id = 0 this.nodohijo = nodohijo this.izquierda = izquierda this.derecha = derecha } } class MerkleTree { constructor() { this.raiz = null } insertar(dato) { let nodo = new Nodo(dato, null, null, true) if (this.raiz == null) { let listatmp = new ListaTemporal() listatmp.insertLista(nodo) listatmp.insertLista(new Nodo(-1, null, null, true)) this.construirArbol(listatmp) } else { let listatmp = this.ObtenerLista() listatmp.insertLista(nodo) this.construirArbol(listatmp) } this.hashing() contadorglobal = 0 } ObtenerLista() { let listatmp = new ListaTemporal() this.obtenerlista(listatmp, this.raiz.izquierda) this.obtenerlista(listatmp, this.raiz.derecha) return listatmp } obtenerlista(lista, nodo) { if (nodo != null) { this.obtenerlista(lista, nodo.izquierda) if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) { lista.insertLista(nodo) } this.obtenerlista(lista, nodo.derecha) } } construirArbol(lista) { let tamanio = new Float64Array(lista.size) let cant = 1 let operacion = tamanio.length / 2 while (operacion > 1) { cant++ operacion = operacion / 2 } let vectorTotal = new Float64Array(cant) let totalnodos = Math.pow(2, vectorTotal.length) while (lista.size < Math.floor(totalnodos)) { lista.insertLista(new Nodo(-1, null, null, true)) } while (lista.size > 1) { let primero = lista.cabeza let segundo = primero.siguiente lista.eliminarLista(primero.datTemporal) lista.eliminarLista(segundo.datTemporal) let nodo1 = primero.datTemporal nodo1.id = contadorglobal + 1 let nodo2 = segundo.datTemporal nodo2.id = contadorglobal + 2 let suma = nodo1.dato + nodo2.dato let nuevo = new Nodo(suma, nodo1, nodo2, false) nuevo.id = contadorglobal lista.insertLista(nuevo) contadorglobal = contadorglobal + 3 } this.raiz = lista.cabeza.datTemporal } hashing() { if (this.raiz == null) { console.log(\"No existe arbol\") return } this.subHashing(this.raiz) } subHashing(nodo) { if (nodo != null) { let hasheo = Sha256.hash(String(nodo.dato)) nodo.hash = hasheo this.subHashing(nodo.izquierda) this.subHashing(nodo.derecha) } } imprimiendo() { if (this.raiz == null) { console.log(\"No existe arbol\") return } this.imprimir(this.raiz) } imprimir(nodo) { if (nodo != null) { console.log(nodo.dato + \" Es el dato\") console.log(nodo.hash + \" Es el Hash\") this.imprimir(nodo.izquierda) this.imprimir(nodo.derecha) } } preOrden(nodo, vector) { if (nodo != null) { vector.push(nodo.dato) this.preOrden(nodo.izquierda, vector) this.preOrden(nodo.derecha, vector) } return vector } graficar(valorBuscar) { salida = \"\" if (this.raiz == null) { console.log(\"No hay nada aun\") return } let nodo = this.raiz let contador = 0 salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\" this.graficando(nodo, valorBuscar) salida += \"}\" contador = 0 d3.select(' .width(750) .height(400) .renderDot(salida) return console.log(salida) } graficando(nodo, valorBuscar) { if (nodo != null) { if (valorBuscar == nodo.dato) { salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\" \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\" } else { salida += \"node\" + nodo.id + \" [label = \\\" \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\" } if (nodo.derecha != null) { salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\" } if (nodo.izquierda != null) { salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\" } if (nodo.izquierda != null) { this.graficando(nodo.izquierda, valorBuscar) } if (nodo.derecha != null) { this.graficando(nodo.derecha, valorBuscar) } } } getMerkleRoot() { return this.raiz.hash } } let Transacciones = new MerkleTree() Transacciones.graficar(0)"
                                },
                                "block2": {
                                    "start_line": 0,
                                    "end_line": 50,
                                    "code": "import LinkedList from \"../data_structs/linked_list.js\"; class _Block{ constructor({ index, timeStamp, prevHash, rootMerkle, data, }){ this.index = index; this.timeStamp = timeStamp; this.prevHash = prevHash; this.rootMerkle = rootMerkle; this.data = data; this.hash = this._genHash(); this.nonce = 0; this._proofOfWork(); } _proofOfWork(){ while(!this.hash.startsWith('00')){ this.nonce++; this.hash = this._genHash(); } } _genHash(){ return Sha256.hash(this.index+this.timeStamp+this.prevHash+this.root+this.nonce); } toString(){ return ` bloque: ${this.index}\\\\n hash: ${this.hash}\\\\n nonce: ${this.nonce}\\\\n prev: ${this.prevHash}\\\\n rootMerkle: ${this.rootMerkle}\\\\n transacciones:\\\\n ${this.data} timeStamp: ${this.timeStamp} `; } } export default class BlockChain{ constructor(){ this.blocks = new LinkedList(); this.index = 0; } genNewBlock(timeStamp, root, list){ const data = { index: this.index++, timeStamp: timeStamp, prevHash: (this.blocks.isEmpty()) ? this.blocks.end.data.hash : '', rootMerkle: root, data: list, }; this.blocks.add(new _Block(data)); } } var Sha256 = {}; Sha256.hash = function (msg, utf8encode) { utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode; if (utf8encode) msg = Utf8.encode(msg); var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]; var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]; msg += String.fromCharCode(0x80); var l = msg.length / 4 + 2; var N = Math.ceil(l / 16); var M = new Array(N); for (var i = 0; i < N; i++) { M[i] = new Array(16); for (var j = 0; j < 16; j++) { M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) | (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3)); } } M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14]) M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff; var W = new Array(64); var a, b, c, d, e, f, g, h; for (var i = 0; i < N; i++) { for (var t = 0; t < 16; t++) W[t] = M[i][t]; for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff; a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7]; for (var t = 0; t < 64; t++) { var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t]; var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c); h = g; g = f; f = e; e = (d + T1) & 0xffffffff; d = c; c = b; b = a; a = (T1 + T2) & 0xffffffff; } H[0] = (H[0] + a) & 0xffffffff; H[1] = (H[1] + b) & 0xffffffff; H[2] = (H[2] + c) & 0xffffffff; H[3] = (H[3] + d) & 0xffffffff; H[4] = (H[4] + e) & 0xffffffff; H[5] = (H[5] + f) & 0xffffffff; H[6] = (H[6] + g) & 0xffffffff; H[7] = (H[7] + h) & 0xffffffff; } return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) + Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]); } Sha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); } Sha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); } Sha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); } Sha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); } Sha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); } Sha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); } Sha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); } Sha256.toHexStr = function (n) { var s = \"\", v; for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); } return s; } var Utf8 = {}; Utf8.encode = function (strUni) { var strUtf = strUni.replace( /[\\u0080-\\u07ff]/g, function (c) { var cc = c.charCodeAt(0); return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f); } ); strUtf = strUtf.replace( /[\\u0800-\\uffff]/g, function (c) { var cc = c.charCodeAt(0); return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f); } ); return strUtf; } Utf8.decode = function (strUtf) { var strUni = strUtf.replace( /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g, function (c) { var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f); return String.fromCharCode(cc); } ); strUni = strUni.replace( /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g, function (c) { var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f; return String.fromCharCode(cc); } ); return strUni; }"
                                },
                                "similarity": 0.7832133332332992,
                                "similarity_details": {
                                    "tfidf": 0.8028736418297481,
                                    "char_ngram": 0.6825066322237517,
                                    "word_ngram": 0.48358712367656415,
                                    "embedding": 0.9735496044158936
                                }
                            }
                        ]
                    }
                ]
            }
        ],
        "detailed_pairs": [
            {
                "file1": {
                    "submission": "extracted_-EDD_junio-Proyecto2_201800992-main",
                    "path": "-EDD_junio-Proyecto2_201800992-main\\js\\BlockChain\\blockChain.js",
                    "full_path": "C:\\Users\\gian-\\AppData\\Local\\Temp\\plagiarism_checker\\323c8304-f54c-4baa-a6a4-eefec5065d1f\\extracted_-EDD_junio-Proyecto2_201800992-main\\-EDD_junio-Proyecto2_201800992-main\\js\\BlockChain\\blockChain.js"
                },
                "file2": {
                    "submission": "extracted_-EDD_junio-Proyecto2_201801178-main",
                    "path": "-EDD_junio-Proyecto2_201801178-main\\src\\data_structs\\block.js",
                    "full_path": "C:\\Users\\gian-\\AppData\\Local\\Temp\\plagiarism_checker\\323c8304-f54c-4baa-a6a4-eefec5065d1f\\extracted_-EDD_junio-Proyecto2_201801178-main\\-EDD_junio-Proyecto2_201801178-main\\src\\data_structs\\block.js"
                },
                "token_similarity": 0.7660278148232484,
                "token_similarity_details": {
                    "lcs": 0.7007984969469234,
                    "sequence_matcher": 0.7655207798871216,
                    "ngram": 0.8505392912172574,
                    "levenshtein": 0.5512993721687991,
                    "tfidf_cosine": 0.9904826612897049,
                    "winnowing": 0.6761565836298933
                },
                "ml_similarity": 0.8959310634607047,
                "ml_similarity_details": {
                    "tfidf": 0.91361488423569,
                    "char_ngram": 0.9145146556404588,
                    "word_ngram": 0.7044265089909426,
                    "embedding": 0.9735496044158936
                },
                "combined_similarity": 0.817989114278231,
                "similar_fragments": [
                    {
                        "fragment1": [
                            0,
                            20
                        ],
                        "fragment2": [
                            280,
                            300
                        ],
                        "similarity": 0.7727474779549475,
                        "tokens1": [
                            "var",
                            "ID_Identifier",
                            "=",
                            "{",
                            "}",
                            ";",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ",",
                            "ID_Identifier",
                            ")",
                            "{",
                            "ID_Identifier",
                            "=",
                            "("
                        ],
                        "tokens2": [
                            "{",
                            "}",
                            ";",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ",",
                            "ID_Identifier",
                            ")",
                            "{",
                            "ID_Identifier",
                            "=",
                            "(",
                            "typeof",
                            "ID_Identifier",
                            "=="
                        ],
                        "similarity_details": {
                            "lcs": 0.85,
                            "sequence_matcher": 0.85,
                            "ngram": 0.8333333333333334,
                            "levenshtein": 0.6451612903225806,
                            "tfidf_cosine": 0.8602427661188232,
                            "winnowing": 0.5
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                        "code2": "import LinkedList from \"../data_structs/linked_list.js\";\n\nclass _Block{\n    constructor({\n        index,\n        timeStamp,\n        prevHash,\n        rootMerkle,\n        data,\n    }){\n        this.index = index;\n        this.timeStamp = timeStamp;\n        this.prevHash = prevHash;\n        this.rootMerkle = rootMerkle;\n        this.data = data;\n        this.hash = this._genHash();\n        this.nonce = 0;\n        this._proofOfWork();\n    }\n    _proofOfWork(){\n        while(!this.hash.startsWith('00')){\n            this.nonce++;\n            this.hash = this._genHash();\n        }\n    }\n    _genHash(){\n        return Sha256.hash(this.index+this.timeStamp+this.prevHash+this.root+this.nonce);\n    }\n    toString(){\n        return `\n        bloque: ${this.index}\\\\n\n        hash: ${this.hash}\\\\n\n        nonce: ${this.nonce}\\\\n\n        prev: ${this.prevHash}\\\\n\n        rootMerkle: ${this.rootMerkle}\\\\n\n        transacciones:\\\\n\n        ${this.data}\n        timeStamp: ${this.timeStamp}\n        `;\n    }\n}\n\nexport default class BlockChain{\n    constructor(){\n        this.blocks = new LinkedList();\n        this.index = 0;\n    }\n    genNewBlock(timeStamp, root, list){\n        const data = {\n            index: this.index++,\n            timeStamp: timeStamp,\n            prevHash: (this.blocks.isEmpty()) ? this.blocks.end.data.hash : '',\n            rootMerkle: root,\n            data: list,\n        };\n        this.blocks.add(new _Block(data));\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                    },
                    {
                        "fragment1": [
                            0,
                            1200
                        ],
                        "fragment2": [
                            1520,
                            1540
                        ],
                        "similarity": 0.9412181204694048,
                        "tokens1": [
                            "var",
                            "ID_Identifier",
                            "=",
                            "{",
                            "}",
                            ";",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ",",
                            "ID_Identifier",
                            ")",
                            "{",
                            "ID_Identifier",
                            "=",
                            "("
                        ],
                        "tokens2": [
                            ";",
                            "}",
                            "var",
                            "ID_Identifier",
                            "=",
                            "{",
                            "}",
                            ";",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ")",
                            "{",
                            "var",
                            "ID_Identifier",
                            "="
                        ],
                        "similarity_details": {
                            "lcs": 0.85,
                            "sequence_matcher": 0.85,
                            "ngram": 0.6666666666666666,
                            "levenshtein": 0.8083333333333333,
                            "tfidf_cosine": 0.8000834850559742,
                            "winnowing": 0.25
                        },
                        "code1": "\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                        "code2": "import LinkedList from \"../data_structs/linked_list.js\";\n\nclass _Block{\n    constructor({\n        index,\n        timeStamp,\n        prevHash,\n        rootMerkle,\n        data,\n    }){\n        this.index = index;\n        this.timeStamp = timeStamp;\n        this.prevHash = prevHash;\n        this.rootMerkle = rootMerkle;\n        this.data = data;\n        this.hash = this._genHash();\n        this.nonce = 0;\n        this._proofOfWork();\n    }\n    _proofOfWork(){\n        while(!this.hash.startsWith('00')){\n            this.nonce++;\n            this.hash = this._genHash();\n        }\n    }\n    _genHash(){\n        return Sha256.hash(this.index+this.timeStamp+this.prevHash+this.root+this.nonce);\n    }\n    toString(){\n        return `\n        bloque: ${this.index}\\\\n\n        hash: ${this.hash}\\\\n\n        nonce: ${this.nonce}\\\\n\n        prev: ${this.prevHash}\\\\n\n        rootMerkle: ${this.rootMerkle}\\\\n\n        transacciones:\\\\n\n        ${this.data}\n        timeStamp: ${this.timeStamp}\n        `;\n    }\n}\n\nexport default class BlockChain{\n    constructor(){\n        this.blocks = new LinkedList();\n        this.index = 0;\n    }\n    genNewBlock(timeStamp, root, list){\n        const data = {\n            index: this.index++,\n            timeStamp: timeStamp,\n            prevHash: (this.blocks.isEmpty()) ? this.blocks.end.data.hash : '',\n            rootMerkle: root,\n            data: list,\n        };\n        this.blocks.add(new _Block(data));\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                    },
                    {
                        "fragment1": [
                            1180,
                            1320
                        ],
                        "fragment2": [
                            1630,
                            1660
                        ],
                        "similarity": 0.9407070962311863,
                        "tokens1": [
                            "ID_Identifier",
                            "&",
                            "ID_Identifier",
                            ")",
                            ";",
                            "}",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ")",
                            "{",
                            "var",
                            "ID_Identifier",
                            "=",
                            "\"\"",
                            ","
                        ],
                        "tokens2": [
                            ";",
                            "}",
                            ")",
                            ";",
                            "return",
                            "ID_Identifier",
                            ";",
                            "}",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ")",
                            "{",
                            "var",
                            "ID_Identifier",
                            "="
                        ],
                        "similarity_details": {
                            "lcs": 0.75,
                            "sequence_matcher": 0.75,
                            "ngram": 0.6666666666666666,
                            "levenshtein": 0.8264462809917356,
                            "tfidf_cosine": 0.7380386116058992,
                            "winnowing": 0.5
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                        "code2": "import LinkedList from \"../data_structs/linked_list.js\";\n\nclass _Block{\n    constructor({\n        index,\n        timeStamp,\n        prevHash,\n        rootMerkle,\n        data,\n    }){\n        this.index = index;\n        this.timeStamp = timeStamp;\n        this.prevHash = prevHash;\n        this.rootMerkle = rootMerkle;\n        this.data = data;\n        this.hash = this._genHash();\n        this.nonce = 0;\n        this._proofOfWork();\n    }\n    _proofOfWork(){\n        while(!this.hash.startsWith('00')){\n            this.nonce++;\n            this.hash = this._genHash();\n        }\n    }\n    _genHash(){\n        return Sha256.hash(this.index+this.timeStamp+this.prevHash+this.root+this.nonce);\n    }\n    toString(){\n        return `\n        bloque: ${this.index}\\\\n\n        hash: ${this.hash}\\\\n\n        nonce: ${this.nonce}\\\\n\n        prev: ${this.prevHash}\\\\n\n        rootMerkle: ${this.rootMerkle}\\\\n\n        transacciones:\\\\n\n        ${this.data}\n        timeStamp: ${this.timeStamp}\n        `;\n    }\n}\n\nexport default class BlockChain{\n    constructor(){\n        this.blocks = new LinkedList();\n        this.index = 0;\n    }\n    genNewBlock(timeStamp, root, list){\n        const data = {\n            index: this.index++,\n            timeStamp: timeStamp,\n            prevHash: (this.blocks.isEmpty()) ? this.blocks.end.data.hash : '',\n            rootMerkle: root,\n            data: list,\n        };\n        this.blocks.add(new _Block(data));\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                    },
                    {
                        "fragment1": [
                            1300,
                            1480
                        ],
                        "fragment2": [
                            1710,
                            1760
                        ],
                        "similarity": 0.8763965607972026,
                        "tokens1": [
                            ")",
                            ";",
                            "}",
                            ")",
                            ";",
                            "ID_Identifier",
                            "=",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "(",
                            "/[\\u0800-\\uffff]/g",
                            ",",
                            "function",
                            "(",
                            "ID_Identifier",
                            ")",
                            "{",
                            "var",
                            "ID_Identifier"
                        ],
                        "tokens2": [
                            "ID_Identifier",
                            ")",
                            ";",
                            "}",
                            ")",
                            ";",
                            "ID_Identifier",
                            "=",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "(",
                            "/[\\u00c0-\\u00df][\\u0080-\\u00bf]/g",
                            ",",
                            "function",
                            "(",
                            "ID_Identifier",
                            ")",
                            "{",
                            "var"
                        ],
                        "similarity_details": {
                            "lcs": 0.9,
                            "sequence_matcher": 0.9,
                            "ngram": 0.7777777777777778,
                            "levenshtein": 0.6642857142857144,
                            "tfidf_cosine": 0.8426362202458457,
                            "winnowing": 0.3333333333333333
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                        "code2": "import LinkedList from \"../data_structs/linked_list.js\";\n\nclass _Block{\n    constructor({\n        index,\n        timeStamp,\n        prevHash,\n        rootMerkle,\n        data,\n    }){\n        this.index = index;\n        this.timeStamp = timeStamp;\n        this.prevHash = prevHash;\n        this.rootMerkle = rootMerkle;\n        this.data = data;\n        this.hash = this._genHash();\n        this.nonce = 0;\n        this._proofOfWork();\n    }\n    _proofOfWork(){\n        while(!this.hash.startsWith('00')){\n            this.nonce++;\n            this.hash = this._genHash();\n        }\n    }\n    _genHash(){\n        return Sha256.hash(this.index+this.timeStamp+this.prevHash+this.root+this.nonce);\n    }\n    toString(){\n        return `\n        bloque: ${this.index}\\\\n\n        hash: ${this.hash}\\\\n\n        nonce: ${this.nonce}\\\\n\n        prev: ${this.prevHash}\\\\n\n        rootMerkle: ${this.rootMerkle}\\\\n\n        transacciones:\\\\n\n        ${this.data}\n        timeStamp: ${this.timeStamp}\n        `;\n    }\n}\n\nexport default class BlockChain{\n    constructor(){\n        this.blocks = new LinkedList();\n        this.index = 0;\n    }\n    genNewBlock(timeStamp, root, list){\n        const data = {\n            index: this.index++,\n            timeStamp: timeStamp,\n            prevHash: (this.blocks.isEmpty()) ? this.blocks.end.data.hash : '',\n            rootMerkle: root,\n            data: list,\n        };\n        this.blocks.add(new _Block(data));\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                    },
                    {
                        "fragment1": [
                            1650,
                            1670
                        ],
                        "fragment2": [
                            120,
                            140
                        ],
                        "similarity": 0.7536076945309456,
                        "tokens1": [
                            "ID_Identifier",
                            "=",
                            "this",
                            ".",
                            "ID_Identifier",
                            "+",
                            "this",
                            ".",
                            "ID_Identifier",
                            "+",
                            "this",
                            ".",
                            "ID_Identifier",
                            "+",
                            "this",
                            ".",
                            "ID_Identifier",
                            "while",
                            "(",
                            "ID_Identifier"
                        ],
                        "tokens2": [
                            "this",
                            ".",
                            "ID_Identifier",
                            "+",
                            "this",
                            ".",
                            "ID_Identifier",
                            "+",
                            "this",
                            ".",
                            "ID_Identifier",
                            "+",
                            "this",
                            ".",
                            "ID_Identifier",
                            "+",
                            "this",
                            ".",
                            "ID_Identifier",
                            ")"
                        ],
                        "similarity_details": {
                            "lcs": 0.8,
                            "sequence_matcher": 0.8,
                            "ngram": 0.7222222222222222,
                            "levenshtein": 0.8110236220472441,
                            "tfidf_cosine": 0.9097926283852613,
                            "winnowing": 0.25
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                        "code2": "import LinkedList from \"../data_structs/linked_list.js\";\n\nclass _Block{\n    constructor({\n        index,\n        timeStamp,\n        prevHash,\n        rootMerkle,\n        data,\n    }){\n        this.index = index;\n        this.timeStamp = timeStamp;\n        this.prevHash = prevHash;\n        this.rootMerkle = rootMerkle;\n        this.data = data;\n        this.hash = this._genHash();\n        this.nonce = 0;\n        this._proofOfWork();\n    }\n    _proofOfWork(){\n        while(!this.hash.startsWith('00')){\n            this.nonce++;\n            this.hash = this._genHash();\n        }\n    }\n    _genHash(){\n        return Sha256.hash(this.index+this.timeStamp+this.prevHash+this.root+this.nonce);\n    }\n    toString(){\n        return `\n        bloque: ${this.index}\\\\n\n        hash: ${this.hash}\\\\n\n        nonce: ${this.nonce}\\\\n\n        prev: ${this.prevHash}\\\\n\n        rootMerkle: ${this.rootMerkle}\\\\n\n        transacciones:\\\\n\n        ${this.data}\n        timeStamp: ${this.timeStamp}\n        `;\n    }\n}\n\nexport default class BlockChain{\n    constructor(){\n        this.blocks = new LinkedList();\n        this.index = 0;\n    }\n    genNewBlock(timeStamp, root, list){\n        const data = {\n            index: this.index++,\n            timeStamp: timeStamp,\n            prevHash: (this.blocks.isEmpty()) ? this.blocks.end.data.hash : '',\n            rootMerkle: root,\n            data: list,\n        };\n        this.blocks.add(new _Block(data));\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;"
                    },
                    {
                        "fragment1": [
                            1750,
                            1790
                        ],
                        "fragment2": [
                            20,
                            60
                        ],
                        "similarity": 0.9765058852081059,
                        "tokens1": [
                            ".",
                            "ID_Identifier",
                            "=",
                            "ID_Identifier",
                            ";",
                            "this",
                            ".",
                            "ID_Identifier",
                            "=",
                            "ID_Identifier",
                            ";",
                            "this",
                            ".",
                            "ID_Identifier",
                            "=",
                            "ID_Identifier",
                            ";",
                            "this",
                            ".",
                            "ID_Identifier"
                        ],
                        "tokens2": [
                            ",",
                            "}",
                            ")",
                            "{",
                            "this",
                            ".",
                            "ID_Identifier",
                            "=",
                            "ID_Identifier",
                            ";",
                            "this",
                            ".",
                            "ID_Identifier",
                            "=",
                            "ID_Identifier",
                            ";",
                            "this",
                            ".",
                            "ID_Identifier",
                            "="
                        ],
                        "similarity_details": {
                            "lcs": 0.75,
                            "sequence_matcher": 0.75,
                            "ngram": 0.7777777777777778,
                            "levenshtein": 0.7575757575757576,
                            "tfidf_cosine": 0.9055564254530828,
                            "winnowing": 1
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                        "code2": "import LinkedList from \"../data_structs/linked_list.js\";\n\nclass _Block{\n    constructor({\n        index,\n        timeStamp,\n        prevHash,\n        rootMerkle,\n        data,\n    }){\n        this.index = index;\n        this.timeStamp = timeStamp;\n        this.prevHash = prevHash;\n        this.rootMerkle = rootMerkle;\n        this.data = data;\n        this.hash = this._genHash();\n        this.nonce = 0;\n        this._proofOfWork();\n    }\n    _proofOfWork(){\n        while(!this.hash.startsWith('00')){\n            this.nonce++;\n            this.hash = this._genHash();\n        }\n    }\n    _genHash(){\n        return Sha256.hash(this.index+this.timeStamp+this.prevHash+this.root+this.nonce);\n    }\n    toString(){\n        return `\n        bloque: ${this.index}\\\\n\n        hash: ${this.hash}\\\\n\n        nonce: ${this.nonce}\\\\n\n        prev: ${this.prevHash}\\\\n\n        rootMerkle: ${this.rootMerkle}\\\\n\n        transacciones:\\\\n\n        ${this.data}\n        timeStamp: ${this.timeStamp}\n        `;\n    }\n}\n\nexport default class BlockChain{\n    constructor(){\n        this.blocks = new LinkedList();\n        this.index = 0;\n    }\n    genNewBlock(timeStamp, root, list){\n        const data = {\n            index: this.index++,\n            timeStamp: timeStamp,\n            prevHash: (this.blocks.isEmpty()) ? this.blocks.end.data.hash : '',\n            rootMerkle: root,\n            data: list,\n        };\n        this.blocks.add(new _Block(data));\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                    },
                    {
                        "fragment1": [
                            1860,
                            1880
                        ],
                        "fragment2": [
                            230,
                            250
                        ],
                        "similarity": 0.7333905011867399,
                        "tokens1": [
                            "(",
                            "this",
                            ".",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            ",",
                            "this",
                            ".",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            ",",
                            "this",
                            ".",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            ",",
                            "this"
                        ],
                        "tokens2": [
                            "(",
                            "this",
                            ".",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "(",
                            ")",
                            ")",
                            "?",
                            "this",
                            ".",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            ":"
                        ],
                        "similarity_details": {
                            "lcs": 0.75,
                            "sequence_matcher": 0.75,
                            "ngram": 0.5,
                            "levenshtein": 0.8373983739837398,
                            "tfidf_cosine": 0.7045541319499595,
                            "winnowing": 1
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                        "code2": "import LinkedList from \"../data_structs/linked_list.js\";\n\nclass _Block{\n    constructor({\n        index,\n        timeStamp,\n        prevHash,\n        rootMerkle,\n        data,\n    }){\n        this.index = index;\n        this.timeStamp = timeStamp;\n        this.prevHash = prevHash;\n        this.rootMerkle = rootMerkle;\n        this.data = data;\n        this.hash = this._genHash();\n        this.nonce = 0;\n        this._proofOfWork();\n    }\n    _proofOfWork(){\n        while(!this.hash.startsWith('00')){\n            this.nonce++;\n            this.hash = this._genHash();\n        }\n    }\n    _genHash(){\n        return Sha256.hash(this.index+this.timeStamp+this.prevHash+this.root+this.nonce);\n    }\n    toString(){\n        return `\n        bloque: ${this.index}\\\\n\n        hash: ${this.hash}\\\\n\n        nonce: ${this.nonce}\\\\n\n        prev: ${this.prevHash}\\\\n\n        rootMerkle: ${this.rootMerkle}\\\\n\n        transacciones:\\\\n\n        ${this.data}\n        timeStamp: ${this.timeStamp}\n        `;\n    }\n}\n\nexport default class BlockChain{\n    constructor(){\n        this.blocks = new LinkedList();\n        this.index = 0;\n    }\n    genNewBlock(timeStamp, root, list){\n        const data = {\n            index: this.index++,\n            timeStamp: timeStamp,\n            prevHash: (this.blocks.isEmpty()) ? this.blocks.end.data.hash : '',\n            rootMerkle: root,\n            data: list,\n        };\n        this.blocks.add(new _Block(data));\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }"
                    }
                ],
                "ml_fragments": [
                    {
                        "type": "ml_block",
                        "block1": {
                            "start_line": 0,
                            "end_line": 50,
                            "code": "var Sha256 = {}; Sha256.hash = function (msg, utf8encode) { utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode; if (utf8encode) msg = Utf8.encode(msg); var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]; var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]; msg += String.fromCharCode(0x80); var l = msg.length / 4 + 2; var N = Math.ceil(l / 16); var M = new Array(N); for (var i = 0; i < N; i++) { M[i] = new Array(16); for (var j = 0; j < 16; j++) { M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) | (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3)); } } M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14]) M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff; var W = new Array(64); var a, b, c, d, e, f, g, h; for (var i = 0; i < N; i++) { for (var t = 0; t < 16; t++) W[t] = M[i][t]; for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff; a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7]; for (var t = 0; t < 64; t++) { var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t]; var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c); h = g; g = f; f = e; e = (d + T1) & 0xffffffff; d = c; c = b; b = a; a = (T1 + T2) & 0xffffffff; } H[0] = (H[0] + a) & 0xffffffff; H[1] = (H[1] + b) & 0xffffffff; H[2] = (H[2] + c) & 0xffffffff; H[3] = (H[3] + d) & 0xffffffff; H[4] = (H[4] + e) & 0xffffffff; H[5] = (H[5] + f) & 0xffffffff; H[6] = (H[6] + g) & 0xffffffff; H[7] = (H[7] + h) & 0xffffffff; } return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) + Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]); } Sha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); } Sha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); } Sha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); } Sha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); } Sha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); } Sha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); } Sha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); } Sha256.toHexStr = function (n) { var s = \"\", v; for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); } return s; } var Utf8 = {}; Utf8.encode = function (strUni) { var strUtf = strUni.replace( /[\\u0080-\\u07ff]/g, function (c) { var cc = c.charCodeAt(0); return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f); } ); strUtf = strUtf.replace( /[\\u0800-\\uffff]/g, function (c) { var cc = c.charCodeAt(0); return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f); } ); return strUtf; } Utf8.decode = function (strUtf) { var strUni = strUtf.replace( /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g, function (c) { var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f); return String.fromCharCode(cc); } ); strUni = strUni.replace( /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g, function (c) { var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f; return String.fromCharCode(cc); } ); return strUni; } class Bloque { constructor() { this.id = 0; this.timestamp = \"\"; this.nonce = 0 this.preHash = \"\" this.rootMerkle = \"\" this.hash = \"\" } setdataTime = () => { var today = new Date(); var dd = String(today.getDate()).padStart(2, '0'); var mm = String(today.getMonth() + 1).padStart(2, '0'); var yyyy = today.getFullYear(); var nowh = today.toLocaleTimeString('en-US') today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh; return today } crearBloque = (merkleRoot) => { this.rootMerkle = merkleRoot var flag = true; this.timestamp = this.setdataTime() let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot while (flag) { let aux = (cambiarDatos + this.nonce) this.hash = Sha256.hash(aux) if (this.hash.substring(0, 2) == ! \"00\") { this.preHash = this.hash flag = false } this.nonce++ } this.id++ } } class NodoBlock { constructor(idblock, hash, preHash, merkleRoot, data, fecha) { this.idblock = idblock; this.hash = hash; this.preHash = preHash; this.merkleRoot = merkleRoot; this.data = data; this.fecha = fecha; this.siguiente = null; console.log(\"++++++\"+this.data) } } class BlockChain { constructor() { this.raiz = null; this.ultimo = null this.bloque = new Bloque() } insertar = (data,merkleroot ) => { console.log(\"-------------\" + data) this.bloque.crearBloque(merkleroot) let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp) if (this.raiz == null) { this.raiz = this.ultimo = nuevo } else { this.ultimo.siguiente = nuevo this.ultimo = nuevo } } graph = () => { var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\"; var temp = this.raiz var nodes = \"\"; var conexiones = \"\"; var Nnode = 0; while (temp != null) { nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\"; if (temp.siguiente != null) { var auxnum = Nnode + 1; conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\"; } temp = temp.siguiente Nnode++; } codigodot += \" codigodot += nodes + \"\\n\" codigodot += \" codigodot += \"\\n\" + conexiones + \"\\n}\\n}\" var svg = d3.select(' .width(500) .height(200) .renderDot(codigodot) return console.log(codigodot) } } let block = new BlockChain()"
                        },
                        "block2": {
                            "start_line": 0,
                            "end_line": 50,
                            "code": "import LinkedList from \"../data_structs/linked_list.js\"; class _Block{ constructor({ index, timeStamp, prevHash, rootMerkle, data, }){ this.index = index; this.timeStamp = timeStamp; this.prevHash = prevHash; this.rootMerkle = rootMerkle; this.data = data; this.hash = this._genHash(); this.nonce = 0; this._proofOfWork(); } _proofOfWork(){ while(!this.hash.startsWith('00')){ this.nonce++; this.hash = this._genHash(); } } _genHash(){ return Sha256.hash(this.index+this.timeStamp+this.prevHash+this.root+this.nonce); } toString(){ return ` bloque: ${this.index}\\\\n hash: ${this.hash}\\\\n nonce: ${this.nonce}\\\\n prev: ${this.prevHash}\\\\n rootMerkle: ${this.rootMerkle}\\\\n transacciones:\\\\n ${this.data} timeStamp: ${this.timeStamp} `; } } export default class BlockChain{ constructor(){ this.blocks = new LinkedList(); this.index = 0; } genNewBlock(timeStamp, root, list){ const data = { index: this.index++, timeStamp: timeStamp, prevHash: (this.blocks.isEmpty()) ? this.blocks.end.data.hash : '', rootMerkle: root, data: list, }; this.blocks.add(new _Block(data)); } } var Sha256 = {}; Sha256.hash = function (msg, utf8encode) { utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode; if (utf8encode) msg = Utf8.encode(msg); var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]; var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]; msg += String.fromCharCode(0x80); var l = msg.length / 4 + 2; var N = Math.ceil(l / 16); var M = new Array(N); for (var i = 0; i < N; i++) { M[i] = new Array(16); for (var j = 0; j < 16; j++) { M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) | (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3)); } } M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14]) M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff; var W = new Array(64); var a, b, c, d, e, f, g, h; for (var i = 0; i < N; i++) { for (var t = 0; t < 16; t++) W[t] = M[i][t]; for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff; a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7]; for (var t = 0; t < 64; t++) { var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t]; var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c); h = g; g = f; f = e; e = (d + T1) & 0xffffffff; d = c; c = b; b = a; a = (T1 + T2) & 0xffffffff; } H[0] = (H[0] + a) & 0xffffffff; H[1] = (H[1] + b) & 0xffffffff; H[2] = (H[2] + c) & 0xffffffff; H[3] = (H[3] + d) & 0xffffffff; H[4] = (H[4] + e) & 0xffffffff; H[5] = (H[5] + f) & 0xffffffff; H[6] = (H[6] + g) & 0xffffffff; H[7] = (H[7] + h) & 0xffffffff; } return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) + Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]); } Sha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); } Sha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); } Sha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); } Sha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); } Sha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); } Sha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); } Sha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); } Sha256.toHexStr = function (n) { var s = \"\", v; for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); } return s; } var Utf8 = {}; Utf8.encode = function (strUni) { var strUtf = strUni.replace( /[\\u0080-\\u07ff]/g, function (c) { var cc = c.charCodeAt(0); return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f); } ); strUtf = strUtf.replace( /[\\u0800-\\uffff]/g, function (c) { var cc = c.charCodeAt(0); return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f); } ); return strUtf; } Utf8.decode = function (strUtf) { var strUni = strUtf.replace( /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g, function (c) { var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f); return String.fromCharCode(cc); } ); strUni = strUni.replace( /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g, function (c) { var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f; return String.fromCharCode(cc); } ); return strUni; }"
                        },
                        "similarity": 0.8959310634607047,
                        "similarity_details": {
                            "tfidf": 0.91361488423569,
                            "char_ngram": 0.9145146556404588,
                            "word_ngram": 0.7044265089909426,
                            "embedding": 0.9735496044158936
                        }
                    }
                ],
                "is_plagiarism": true,
                "plagiarism_probability": 0.8040902838422685,
                "all_features": {
                    "lcs": 0.7007984969469234,
                    "sequence_matcher": 0.7655207798871216,
                    "ngram": 0.8505392912172574,
                    "levenshtein": 0.5512993721687991,
                    "tfidf_cosine": 0.9904826612897049,
                    "winnowing": 0.6761565836298933,
                    "ml_tfidf": 0.91361488423569,
                    "ml_char_ngram": 0.9145146556404588,
                    "ml_word_ngram": 0.7044265089909426,
                    "ml_embedding": 0.9735496044158936
                }
            },
            {
                "file1": {
                    "submission": "extracted_-EDD_junio-Proyecto2_201800992-main",
                    "path": "-EDD_junio-Proyecto2_201800992-main\\js\\BlockChain\\blockChain.js",
                    "full_path": "C:\\Users\\gian-\\AppData\\Local\\Temp\\plagiarism_checker\\323c8304-f54c-4baa-a6a4-eefec5065d1f\\extracted_-EDD_junio-Proyecto2_201800992-main\\-EDD_junio-Proyecto2_201800992-main\\js\\BlockChain\\blockChain.js"
                },
                "file2": {
                    "submission": "extracted_-EDD_junio-Proyecto2_201801178-main",
                    "path": "-EDD_junio-Proyecto2_201801178-main\\src\\data_structs\\merkle.js",
                    "full_path": "C:\\Users\\gian-\\AppData\\Local\\Temp\\plagiarism_checker\\323c8304-f54c-4baa-a6a4-eefec5065d1f\\extracted_-EDD_junio-Proyecto2_201801178-main\\-EDD_junio-Proyecto2_201801178-main\\src\\data_structs\\merkle.js"
                },
                "token_similarity": 0.7658276814671913,
                "token_similarity_details": {
                    "lcs": 0.7007984969469234,
                    "sequence_matcher": 0.7347943856193055,
                    "ngram": 0.8582696573823022,
                    "levenshtein": 0.5665580545180005,
                    "tfidf_cosine": 0.9913484278771787,
                    "winnowing": 0.6725352112676056
                },
                "ml_similarity": 0.8820938949638769,
                "ml_similarity_details": {
                    "tfidf": 0.9089436926233514,
                    "char_ngram": 0.8970035633389773,
                    "word_ngram": 0.6752840782740173,
                    "embedding": 0.9646190404891968
                },
                "combined_similarity": 0.8123341668658655,
                "similar_fragments": [
                    {
                        "fragment1": [
                            0,
                            250
                        ],
                        "fragment2": [
                            440,
                            690
                        ],
                        "similarity": 1.0000000000000009,
                        "tokens1": [
                            "var",
                            "ID_Identifier",
                            "=",
                            "{",
                            "}",
                            ";",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ",",
                            "ID_Identifier",
                            ")",
                            "{",
                            "ID_Identifier",
                            "=",
                            "("
                        ],
                        "tokens2": [
                            "var",
                            "ID_Identifier",
                            "=",
                            "{",
                            "}",
                            ";",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ",",
                            "ID_Identifier",
                            ")",
                            "{",
                            "ID_Identifier",
                            "=",
                            "("
                        ],
                        "similarity_details": {
                            "lcs": 1,
                            "sequence_matcher": 1,
                            "ngram": 1,
                            "levenshtein": 1,
                            "tfidf_cosine": 1,
                            "winnowing": 1
                        },
                        "code1": "\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                        "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                    },
                    {
                        "fragment1": [
                            230,
                            660
                        ],
                        "fragment2": [
                            900,
                            1100
                        ],
                        "similarity": 1.0000000000000007,
                        "tokens1": [
                            "ID_Identifier",
                            "=",
                            "new",
                            "ID_Identifier",
                            "(",
                            "ID_Identifier",
                            ")",
                            ";",
                            "for",
                            "(",
                            "var",
                            "ID_Identifier",
                            "=",
                            "0",
                            ";",
                            "ID_Identifier",
                            "<",
                            "ID_Identifier",
                            ";",
                            "ID_Identifier"
                        ],
                        "tokens2": [
                            "ID_Identifier",
                            ",",
                            "ID_Identifier",
                            ",",
                            "ID_Identifier",
                            ";",
                            "for",
                            "(",
                            "var",
                            "ID_Identifier",
                            "=",
                            "0",
                            ";",
                            "ID_Identifier",
                            "<",
                            "ID_Identifier",
                            ";",
                            "ID_Identifier",
                            "++",
                            ")"
                        ],
                        "similarity_details": {
                            "lcs": 0.8,
                            "sequence_matcher": 0.8,
                            "ngram": 0.6111111111111112,
                            "levenshtein": 0.8992248062015504,
                            "tfidf_cosine": 0.7048900819879953,
                            "winnowing": 1
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                        "code2": "class _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }"
                    },
                    {
                        "fragment1": [
                            640,
                            760
                        ],
                        "fragment2": [
                            1110,
                            1200
                        ],
                        "similarity": 1.0000000000000002,
                        "tokens1": [
                            "var",
                            "ID_Identifier",
                            "=",
                            "ID_Identifier",
                            "+",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "(",
                            "ID_Identifier",
                            ")",
                            "+",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "(",
                            "ID_Identifier",
                            ",",
                            "ID_Identifier",
                            ","
                        ],
                        "tokens2": [
                            "ID_Identifier",
                            "]",
                            ";",
                            "var",
                            "ID_Identifier",
                            "=",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "(",
                            "ID_Identifier",
                            ")",
                            "+",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "(",
                            "ID_Identifier",
                            ",",
                            "ID_Identifier"
                        ],
                        "similarity_details": {
                            "lcs": 0.85,
                            "sequence_matcher": 0.85,
                            "ngram": 0.7777777777777778,
                            "levenshtein": 0.9060402684563759,
                            "tfidf_cosine": 0.9032400268543423,
                            "winnowing": 0.6666666666666666
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                        "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                    },
                    {
                        "fragment1": [
                            740,
                            990
                        ],
                        "fragment2": [
                            1260,
                            1430
                        ],
                        "similarity": 1.0000000000000007,
                        "tokens1": [
                            "[",
                            "0",
                            "]",
                            "=",
                            "(",
                            "ID_Identifier",
                            "[",
                            "0",
                            "]",
                            "+",
                            "ID_Identifier",
                            ")",
                            "&",
                            "0xffffffff",
                            ";",
                            "ID_Identifier",
                            "[",
                            "1",
                            "]",
                            "="
                        ],
                        "tokens2": [
                            "[",
                            "5",
                            "]",
                            "=",
                            "(",
                            "ID_Identifier",
                            "[",
                            "5",
                            "]",
                            "+",
                            "ID_Identifier",
                            ")",
                            "&",
                            "0xffffffff",
                            ";",
                            "ID_Identifier",
                            "[",
                            "6",
                            "]",
                            "="
                        ],
                        "similarity_details": {
                            "lcs": 0.85,
                            "sequence_matcher": 0.85,
                            "ngram": 0.5555555555555556,
                            "levenshtein": 0.9642857142857143,
                            "tfidf_cosine": 0.5644570020409767,
                            "winnowing": 0.3333333333333333
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                        "code2": "\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                    },
                    {
                        "fragment1": [
                            970,
                            990
                        ],
                        "fragment2": [
                            1450,
                            1470
                        ],
                        "similarity": 0.7108814122903837,
                        "tokens1": [
                            "<<",
                            "(",
                            "32",
                            "-",
                            "ID_Identifier",
                            ")",
                            ")",
                            ";",
                            "}",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ")",
                            "{",
                            "return",
                            "ID_Identifier"
                        ],
                        "tokens2": [
                            "(",
                            "22",
                            ",",
                            "ID_Identifier",
                            ")",
                            ";",
                            "}",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ")",
                            "{",
                            "return",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier"
                        ],
                        "similarity_details": {
                            "lcs": 0.8,
                            "sequence_matcher": 0.8,
                            "ngram": 0.6666666666666666,
                            "levenshtein": 0.814516129032258,
                            "tfidf_cosine": 0.7482242657529938,
                            "winnowing": 0.25
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                        "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                    },
                    {
                        "fragment1": [
                            970,
                            1000
                        ],
                        "fragment2": [
                            1490,
                            1510
                        ],
                        "similarity": 1,
                        "tokens1": [
                            "<<",
                            "(",
                            "32",
                            "-",
                            "ID_Identifier",
                            ")",
                            ")",
                            ";",
                            "}",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ")",
                            "{",
                            "return",
                            "ID_Identifier"
                        ],
                        "tokens2": [
                            ",",
                            "ID_Identifier",
                            ")",
                            ";",
                            "}",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ")",
                            "{",
                            "return",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "(",
                            "7"
                        ],
                        "similarity_details": {
                            "lcs": 0.75,
                            "sequence_matcher": 0.75,
                            "ngram": 0.6666666666666666,
                            "levenshtein": 0.7479674796747968,
                            "tfidf_cosine": 0.7482242657529938,
                            "winnowing": 0.5
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                        "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                    },
                    {
                        "fragment1": [
                            980,
                            1140
                        ],
                        "fragment2": [
                            1530,
                            1580
                        ],
                        "similarity": 1.0000000000000007,
                        "tokens1": [
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ")",
                            "{",
                            "return",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "(",
                            "2",
                            ",",
                            "ID_Identifier",
                            ")",
                            "^",
                            "ID_Identifier",
                            "."
                        ],
                        "tokens2": [
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ")",
                            "{",
                            "return",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "(",
                            "17",
                            ",",
                            "ID_Identifier",
                            ")",
                            "^",
                            "ID_Identifier"
                        ],
                        "similarity_details": {
                            "lcs": 0.9,
                            "sequence_matcher": 0.9,
                            "ngram": 0.7777777777777778,
                            "levenshtein": 0.8676470588235294,
                            "tfidf_cosine": 0.8752690307575414,
                            "winnowing": 0.6666666666666666
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                        "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                    },
                    {
                        "fragment1": [
                            1120,
                            1270
                        ],
                        "fragment2": [
                            1590,
                            1710
                        ],
                        "similarity": 1.0000000000000009,
                        "tokens1": [
                            ">>>",
                            "10",
                            ")",
                            ";",
                            "}",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ",",
                            "ID_Identifier",
                            ",",
                            "ID_Identifier",
                            ")",
                            "{",
                            "return",
                            "("
                        ],
                        "tokens2": [
                            ")",
                            ";",
                            "}",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ",",
                            "ID_Identifier",
                            ",",
                            "ID_Identifier",
                            ")",
                            "{",
                            "return",
                            "(",
                            "ID_Identifier",
                            "&"
                        ],
                        "similarity_details": {
                            "lcs": 0.9,
                            "sequence_matcher": 0.9,
                            "ngram": 0.8888888888888888,
                            "levenshtein": 0.8130081300813008,
                            "tfidf_cosine": 0.8922288908197358,
                            "winnowing": 0.5
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                        "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                    },
                    {
                        "fragment1": [
                            1250,
                            1280
                        ],
                        "fragment2": [
                            1800,
                            1830
                        ],
                        "similarity": 1,
                        "tokens1": [
                            ";",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ")",
                            "{",
                            "var",
                            "ID_Identifier",
                            "=",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "(",
                            "/[\\u0080-\\u07ff]/g",
                            ",",
                            "function"
                        ],
                        "tokens2": [
                            "}",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ")",
                            "{",
                            "var",
                            "ID_Identifier",
                            "=",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "(",
                            "/[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g",
                            ",",
                            "function"
                        ],
                        "similarity_details": {
                            "lcs": 0.9,
                            "sequence_matcher": 0.9,
                            "ngram": 0.7777777777777778,
                            "levenshtein": 0.8160919540229885,
                            "tfidf_cosine": 0.8409526812426942,
                            "winnowing": 1
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                        "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                    },
                    {
                        "fragment1": [
                            1260,
                            1440
                        ],
                        "fragment2": [
                            1880,
                            1900
                        ],
                        "similarity": 1.0000000000000007,
                        "tokens1": [
                            "var",
                            "ID_Identifier",
                            "=",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "(",
                            "/[\\u0080-\\u07ff]/g",
                            ",",
                            "function",
                            "(",
                            "ID_Identifier",
                            ")",
                            "{",
                            "var",
                            "ID_Identifier",
                            "=",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier"
                        ],
                        "tokens2": [
                            "=",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "(",
                            "/[\\u00c0-\\u00df][\\u0080-\\u00bf]/g",
                            ",",
                            "function",
                            "(",
                            "ID_Identifier",
                            ")",
                            "{",
                            "var",
                            "ID_Identifier",
                            "=",
                            "(",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "("
                        ],
                        "similarity_details": {
                            "lcs": 0.85,
                            "sequence_matcher": 0.85,
                            "ngram": 0.6111111111111112,
                            "levenshtein": 0.8157894736842105,
                            "tfidf_cosine": 0.7944040067626077,
                            "winnowing": 0.3333333333333333
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                        "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }"
                    },
                    {
                        "fragment1": [
                            1420,
                            1510
                        ],
                        "fragment2": [
                            1910,
                            1930
                        ],
                        "similarity": 1.0000000000000007,
                        "tokens1": [
                            "ID_Identifier",
                            "(",
                            "2",
                            ")",
                            "&",
                            "0x3f",
                            ")",
                            ";",
                            "return",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "(",
                            "ID_Identifier",
                            ")",
                            ";",
                            "}",
                            ")",
                            ";",
                            "ID_Identifier"
                        ],
                        "tokens2": [
                            "ID_Identifier",
                            "(",
                            "1",
                            ")",
                            "&",
                            "0x3f",
                            ";",
                            "return",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "(",
                            "ID_Identifier",
                            ")",
                            ";",
                            "}",
                            ")",
                            ";",
                            "return",
                            "ID_Identifier"
                        ],
                        "similarity_details": {
                            "lcs": 0.9,
                            "sequence_matcher": 0.9,
                            "ngram": 0.6666666666666666,
                            "levenshtein": 0.9107142857142857,
                            "tfidf_cosine": 0.8000972810214388,
                            "winnowing": 0.14285714285714285
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                        "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                    },
                    {
                        "fragment1": [
                            1740,
                            1790
                        ],
                        "fragment2": [
                            10,
                            30
                        ],
                        "similarity": 0.7258866455167113,
                        "tokens1": [
                            "ID_Identifier",
                            ",",
                            "ID_Identifier",
                            ",",
                            "ID_Identifier",
                            ",",
                            "ID_Identifier",
                            ")",
                            "{",
                            "this",
                            ".",
                            "ID_Identifier",
                            "=",
                            "ID_Identifier",
                            ";",
                            "this",
                            ".",
                            "ID_Identifier",
                            "=",
                            "ID_Identifier"
                        ],
                        "tokens2": [
                            "ID_Identifier",
                            ",",
                            "ID_Identifier",
                            ")",
                            "{",
                            "this",
                            ".",
                            "ID_Identifier",
                            "=",
                            "ID_Identifier",
                            ";",
                            "this",
                            ".",
                            "ID_Identifier",
                            "=",
                            "this",
                            ".",
                            "ID_Identifier",
                            "=",
                            "null"
                        ],
                        "similarity_details": {
                            "lcs": 0.8,
                            "sequence_matcher": 0.8,
                            "ngram": 0.7222222222222222,
                            "levenshtein": 0.7021276595744681,
                            "tfidf_cosine": 0.8384166791201993,
                            "winnowing": 0.3333333333333333
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                        "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;"
                    },
                    {
                        "fragment1": [
                            1800,
                            1830
                        ],
                        "fragment2": [
                            40,
                            70
                        ],
                        "similarity": 0.8471718503999901,
                        "tokens1": [
                            ")",
                            "}",
                            "}",
                            "class",
                            "ID_Identifier",
                            "{",
                            "ID_Identifier",
                            "(",
                            ")",
                            "{",
                            "this",
                            ".",
                            "ID_Identifier",
                            "=",
                            "null",
                            ";",
                            "this",
                            ".",
                            "ID_Identifier",
                            "="
                        ],
                        "tokens2": [
                            "}",
                            "export",
                            "default",
                            "class",
                            "ID_Identifier",
                            "{",
                            "ID_Identifier",
                            "(",
                            ")",
                            "{",
                            "this",
                            ".",
                            "ID_Identifier",
                            "=",
                            "null",
                            ";",
                            "this",
                            ".",
                            "ID_Identifier",
                            "="
                        ],
                        "similarity_details": {
                            "lcs": 0.9,
                            "sequence_matcher": 0.9,
                            "ngram": 0.8333333333333334,
                            "levenshtein": 0.8738738738738738,
                            "tfidf_cosine": 0.8453187114594095,
                            "winnowing": 0.6666666666666666
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                        "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                    },
                    {
                        "fragment1": [
                            1900,
                            1920
                        ],
                        "fragment2": [
                            350,
                            370
                        ],
                        "similarity": 0.716698972693261,
                        "tokens1": [
                            ")",
                            "{",
                            "this",
                            ".",
                            "ID_Identifier",
                            "=",
                            "this",
                            ".",
                            "ID_Identifier",
                            "=",
                            "ID_Identifier",
                            "}",
                            "else",
                            "{",
                            "this",
                            ".",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "="
                        ],
                        "tokens2": [
                            ".",
                            "ID_Identifier",
                            "=",
                            "this",
                            ".",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            ";",
                            "}",
                            "else",
                            "{",
                            "this",
                            ".",
                            "ID_Identifier",
                            "=",
                            "this",
                            ".",
                            "ID_Identifier",
                            "."
                        ],
                        "similarity_details": {
                            "lcs": 0.75,
                            "sequence_matcher": 0.45,
                            "ngram": 0.6666666666666666,
                            "levenshtein": 0.8198198198198199,
                            "tfidf_cosine": 0.863675043646485,
                            "winnowing": 0.6666666666666666
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\nclass Bloque {\n    constructor() {\n        this.id = 0;\n        this.timestamp = \"\";\n        this.nonce = 0\n        this.preHash = \"\"\n        this.rootMerkle = \"\"\n        this.hash = \"\"\n\n    }\n\n\n    setdataTime = () => {\n        var today = new Date();\n        var dd = String(today.getDate()).padStart(2, '0');\n        var mm = String(today.getMonth() + 1).padStart(2, '0');\n        var yyyy = today.getFullYear();\n        var nowh = today.toLocaleTimeString('en-US')\n        today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh;\n        return today\n    }\n\n\n\n    crearBloque = (merkleRoot) => {\n        this.rootMerkle = merkleRoot\n\n        var flag = true;\n        this.timestamp = this.setdataTime()\n        let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot\n        while (flag) {\n            let aux = (cambiarDatos + this.nonce)\n            this.hash = Sha256.hash(aux)\n            if (this.hash.substring(0, 2) == ! \"00\") {\n                this.preHash = this.hash\n                flag = false\n            }\n            this.nonce++\n        }\n\n\n\n        this.id++\n\n    }\n}\n\nclass NodoBlock {\n    constructor(idblock, hash, preHash, merkleRoot, data, fecha) {\n        this.idblock = idblock;\n        this.hash = hash;\n        this.preHash = preHash;\n        this.merkleRoot = merkleRoot;\n        this.data = data;\n        this.fecha = fecha;\n        this.siguiente = null;\n        console.log(\"++++++\"+this.data)\n    }\n}\n\nclass BlockChain {\n    constructor() {\n        this.raiz = null;\n        this.ultimo = null\n        this.bloque = new Bloque()\n    }\n\n    insertar = (data,merkleroot ) => {\n        console.log(\"-------------\" + data)\n        this.bloque.crearBloque(merkleroot)\n       \n        let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp)\n        if (this.raiz == null) {\n            this.raiz = this.ultimo = nuevo\n        } else {\n            this.ultimo.siguiente = nuevo\n            this.ultimo = nuevo\n        }\n    }\n    graph = () => {\n        var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\";\n        var temp = this.raiz\n        var nodes = \"\";\n        var conexiones = \"\";\n        var Nnode = 0;\n\n        while (temp != null) {\n            nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\";\n            if (temp.siguiente != null) {\n                var auxnum = Nnode + 1;\n                conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\";\n            }\n            temp = temp.siguiente\n            Nnode++;\n        }\n        codigodot += \"//agregando nodos\\n\"\n        codigodot += nodes + \"\\n\"\n        codigodot += \"//agregando conexiones o flechas\\n\"\n        codigodot += \"\\n\" + conexiones + \"\\n}\\n}\"\n        \n        var svg = d3.select('#blockChain1').graphviz()\n            .width(500)\n            .height(200)\n            .renderDot(codigodot)\n            return console.log(codigodot)\n    }\n}\n\nlet block = new BlockChain()\n",
                        "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }"
                    }
                ],
                "ml_fragments": [
                    {
                        "type": "ml_block",
                        "block1": {
                            "start_line": 0,
                            "end_line": 50,
                            "code": "var Sha256 = {}; Sha256.hash = function (msg, utf8encode) { utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode; if (utf8encode) msg = Utf8.encode(msg); var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]; var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]; msg += String.fromCharCode(0x80); var l = msg.length / 4 + 2; var N = Math.ceil(l / 16); var M = new Array(N); for (var i = 0; i < N; i++) { M[i] = new Array(16); for (var j = 0; j < 16; j++) { M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) | (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3)); } } M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14]) M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff; var W = new Array(64); var a, b, c, d, e, f, g, h; for (var i = 0; i < N; i++) { for (var t = 0; t < 16; t++) W[t] = M[i][t]; for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff; a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7]; for (var t = 0; t < 64; t++) { var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t]; var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c); h = g; g = f; f = e; e = (d + T1) & 0xffffffff; d = c; c = b; b = a; a = (T1 + T2) & 0xffffffff; } H[0] = (H[0] + a) & 0xffffffff; H[1] = (H[1] + b) & 0xffffffff; H[2] = (H[2] + c) & 0xffffffff; H[3] = (H[3] + d) & 0xffffffff; H[4] = (H[4] + e) & 0xffffffff; H[5] = (H[5] + f) & 0xffffffff; H[6] = (H[6] + g) & 0xffffffff; H[7] = (H[7] + h) & 0xffffffff; } return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) + Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]); } Sha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); } Sha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); } Sha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); } Sha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); } Sha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); } Sha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); } Sha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); } Sha256.toHexStr = function (n) { var s = \"\", v; for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); } return s; } var Utf8 = {}; Utf8.encode = function (strUni) { var strUtf = strUni.replace( /[\\u0080-\\u07ff]/g, function (c) { var cc = c.charCodeAt(0); return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f); } ); strUtf = strUtf.replace( /[\\u0800-\\uffff]/g, function (c) { var cc = c.charCodeAt(0); return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f); } ); return strUtf; } Utf8.decode = function (strUtf) { var strUni = strUtf.replace( /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g, function (c) { var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f); return String.fromCharCode(cc); } ); strUni = strUni.replace( /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g, function (c) { var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f; return String.fromCharCode(cc); } ); return strUni; } class Bloque { constructor() { this.id = 0; this.timestamp = \"\"; this.nonce = 0 this.preHash = \"\" this.rootMerkle = \"\" this.hash = \"\" } setdataTime = () => { var today = new Date(); var dd = String(today.getDate()).padStart(2, '0'); var mm = String(today.getMonth() + 1).padStart(2, '0'); var yyyy = today.getFullYear(); var nowh = today.toLocaleTimeString('en-US') today = dd + '-' + mm + '-' + yyyy + \"-::\" + nowh; return today } crearBloque = (merkleRoot) => { this.rootMerkle = merkleRoot var flag = true; this.timestamp = this.setdataTime() let cambiarDatos = this.id + this.timestamp + this.preHash + this.merkleRoot while (flag) { let aux = (cambiarDatos + this.nonce) this.hash = Sha256.hash(aux) if (this.hash.substring(0, 2) == ! \"00\") { this.preHash = this.hash flag = false } this.nonce++ } this.id++ } } class NodoBlock { constructor(idblock, hash, preHash, merkleRoot, data, fecha) { this.idblock = idblock; this.hash = hash; this.preHash = preHash; this.merkleRoot = merkleRoot; this.data = data; this.fecha = fecha; this.siguiente = null; console.log(\"++++++\"+this.data) } } class BlockChain { constructor() { this.raiz = null; this.ultimo = null this.bloque = new Bloque() } insertar = (data,merkleroot ) => { console.log(\"-------------\" + data) this.bloque.crearBloque(merkleroot) let nuevo = new NodoBlock(this.bloque.id, this.bloque.hash, this.bloque.preHash, this.bloque.rootMerkle, data, this.bloque.timestamp) if (this.raiz == null) { this.raiz = this.ultimo = nuevo } else { this.ultimo.siguiente = nuevo this.ultimo = nuevo } } graph = () => { var codigodot = \"digraph G{\\nbgcolor=none\\nrankdir=LR;\\nlabel=\\\" Usuarios \\\";\\nnode [shape=box];\\n nodesep=1;\\n\" + \"node [shape=record fontname=Arial]\\n;\"; var temp = this.raiz var nodes = \"\"; var conexiones = \"\"; var Nnode = 0; while (temp != null) { nodes += \"N\" + Nnode + \" [label=\\\"\" + \"\\\\n\" + \"ID: \"+temp.idblock + \"\\\\n\" + \"HASH: \"+temp.hash + \"\\\\n\" + \"PreHash: \"+temp.preHash + \"\\\\n\" +\"MerkleRoot: \" +temp.merkleRoot + \"\\\\n\" + \"Data: \"+temp.data + \"\\\\n\" +\"Fecha: \"+ temp.fecha + \"\\\\n\" + \"\\\"];\\n\"; if (temp.siguiente != null) { var auxnum = Nnode + 1; conexiones += \"N\" + Nnode + \" -> N\" + auxnum + \";\\n\"; } temp = temp.siguiente Nnode++; } codigodot += \" codigodot += nodes + \"\\n\" codigodot += \" codigodot += \"\\n\" + conexiones + \"\\n}\\n}\" var svg = d3.select(' .width(500) .height(200) .renderDot(codigodot) return console.log(codigodot) } } let block = new BlockChain()"
                        },
                        "block2": {
                            "start_line": 0,
                            "end_line": 50,
                            "code": "import LinkedList from \"./linked_list.js\"; class _Node{ constructor(data,id){ this.data = data; this.left = this.right = null; this.id = `n${id}`; } } export default class MerkleTree{ constructor(){ this.root = null; this.dataBlocks = null; this.curr_block = null; this.junkBlocks = null; this.id = 0; } _fillDataBlocks(){ let n = 1; let powerOf2 = Math.pow(2,n); while(powerOf2 < this.dataBlocks.len){ n++; powerOf2 = Math.pow(2,n); } this.junkBlocks = new LinkedList(); for (let i = this.dataBlocks.len; i < powerOf2; i++) { this.junkBlocks.add(i*100); } return n; } genTree(list){ if(list.isEmpty()){ this.dataBlocks = list; this.curr_block = this.dataBlocks.head; const exp = this._fillDataBlocks(); this.root = new _Node(null, this.id++); this._genTreeRec(this.root, exp); this._genHash(this.root); } } _genTreeRec(root, exp){ if(exp > 0){ root.left = new _Node(null, this.id++); root.right = new _Node(null, this.id++); this._genTreeRec(root.left, exp-1); this._genTreeRec(root.right, exp-1); } else{ root.data = Sha256.hash(this.curr_block.data.toString()); if(this.curr_block.next){ this.curr_block = this.curr_block.next; } else{ this.curr_block = this.junkBlocks.head; } } } _genHash(root){ if(root == null){ return; } this._genHash(root.left); this._genHash(root.right); if(!root.data){ root.data = Sha256.hash(root.left.data + root.right.data); } } } var Sha256 = {}; Sha256.hash = function (msg, utf8encode) { utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode; if (utf8encode) msg = Utf8.encode(msg); var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]; var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]; msg += String.fromCharCode(0x80); var l = msg.length / 4 + 2; var N = Math.ceil(l / 16); var M = new Array(N); for (var i = 0; i < N; i++) { M[i] = new Array(16); for (var j = 0; j < 16; j++) { M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) | (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3)); } } M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14]) M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff; var W = new Array(64); var a, b, c, d, e, f, g, h; for (var i = 0; i < N; i++) { for (var t = 0; t < 16; t++) W[t] = M[i][t]; for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff; a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7]; for (var t = 0; t < 64; t++) { var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t]; var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c); h = g; g = f; f = e; e = (d + T1) & 0xffffffff; d = c; c = b; b = a; a = (T1 + T2) & 0xffffffff; } H[0] = (H[0] + a) & 0xffffffff; H[1] = (H[1] + b) & 0xffffffff; H[2] = (H[2] + c) & 0xffffffff; H[3] = (H[3] + d) & 0xffffffff; H[4] = (H[4] + e) & 0xffffffff; H[5] = (H[5] + f) & 0xffffffff; H[6] = (H[6] + g) & 0xffffffff; H[7] = (H[7] + h) & 0xffffffff; } return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) + Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]); } Sha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); } Sha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); } Sha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); } Sha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); } Sha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); } Sha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); } Sha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); } Sha256.toHexStr = function (n) { var s = \"\", v; for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); } return s; } var Utf8 = {}; Utf8.encode = function (strUni) { var strUtf = strUni.replace( /[\\u0080-\\u07ff]/g, function (c) { var cc = c.charCodeAt(0); return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f); } ); strUtf = strUtf.replace( /[\\u0800-\\uffff]/g, function (c) { var cc = c.charCodeAt(0); return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f); } ); return strUtf; } Utf8.decode = function (strUtf) { var strUni = strUtf.replace( /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g, function (c) { var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f); return String.fromCharCode(cc); } ); strUni = strUni.replace( /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g, function (c) { var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f; return String.fromCharCode(cc); } ); return strUni; }"
                        },
                        "similarity": 0.8820938949638769,
                        "similarity_details": {
                            "tfidf": 0.9089436926233514,
                            "char_ngram": 0.8970035633389773,
                            "word_ngram": 0.6752840782740173,
                            "embedding": 0.9646190404891968
                        }
                    }
                ],
                "is_plagiarism": true,
                "plagiarism_probability": 0.7970154608336859,
                "all_features": {
                    "lcs": 0.7007984969469234,
                    "sequence_matcher": 0.7347943856193055,
                    "ngram": 0.8582696573823022,
                    "levenshtein": 0.5665580545180005,
                    "tfidf_cosine": 0.9913484278771787,
                    "winnowing": 0.6725352112676056,
                    "ml_tfidf": 0.9089436926233514,
                    "ml_char_ngram": 0.8970035633389773,
                    "ml_word_ngram": 0.6752840782740173,
                    "ml_embedding": 0.9646190404891968
                }
            },
            {
                "file1": {
                    "submission": "extracted_-EDD_junio-Proyecto2_201800992-main",
                    "path": "-EDD_junio-Proyecto2_201800992-main\\js\\Arboles\\arbolMerkle.js",
                    "full_path": "C:\\Users\\gian-\\AppData\\Local\\Temp\\plagiarism_checker\\323c8304-f54c-4baa-a6a4-eefec5065d1f\\extracted_-EDD_junio-Proyecto2_201800992-main\\-EDD_junio-Proyecto2_201800992-main\\js\\Arboles\\arbolMerkle.js"
                },
                "file2": {
                    "submission": "extracted_-EDD_junio-Proyecto2_201801178-main",
                    "path": "-EDD_junio-Proyecto2_201801178-main\\src\\data_structs\\merkle.js",
                    "full_path": "C:\\Users\\gian-\\AppData\\Local\\Temp\\plagiarism_checker\\323c8304-f54c-4baa-a6a4-eefec5065d1f\\extracted_-EDD_junio-Proyecto2_201801178-main\\-EDD_junio-Proyecto2_201801178-main\\src\\data_structs\\merkle.js"
                },
                "token_similarity": 0.681456263861494,
                "token_similarity_details": {
                    "lcs": 0.5259076489249207,
                    "sequence_matcher": 0.6257076955336549,
                    "ngram": 0.7492130115424974,
                    "levenshtein": 0.5059020946649693,
                    "tfidf_cosine": 0.9787062770831157,
                    "winnowing": 0.6194968553459119
                },
                "ml_similarity": 0.7826109736901622,
                "ml_similarity_details": {
                    "tfidf": 0.8135298074469223,
                    "char_ngram": 0.70211477395347,
                    "word_ngram": 0.46817214646738037,
                    "embedding": 0.9646190404891968
                },
                "combined_similarity": 0.7219181477929613,
                "similar_fragments": [
                    {
                        "fragment1": [
                            0,
                            250
                        ],
                        "fragment2": [
                            440,
                            690
                        ],
                        "similarity": 1.0000000000000009,
                        "tokens1": [
                            "var",
                            "ID_Identifier",
                            "=",
                            "{",
                            "}",
                            ";",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ",",
                            "ID_Identifier",
                            ")",
                            "{",
                            "ID_Identifier",
                            "=",
                            "("
                        ],
                        "tokens2": [
                            "var",
                            "ID_Identifier",
                            "=",
                            "{",
                            "}",
                            ";",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ",",
                            "ID_Identifier",
                            ")",
                            "{",
                            "ID_Identifier",
                            "=",
                            "("
                        ],
                        "similarity_details": {
                            "lcs": 1,
                            "sequence_matcher": 1,
                            "ngram": 1,
                            "levenshtein": 1,
                            "tfidf_cosine": 1,
                            "winnowing": 1
                        },
                        "code1": "\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                        "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                    },
                    {
                        "fragment1": [
                            230,
                            660
                        ],
                        "fragment2": [
                            900,
                            1100
                        ],
                        "similarity": 1.0000000000000007,
                        "tokens1": [
                            "ID_Identifier",
                            "=",
                            "new",
                            "ID_Identifier",
                            "(",
                            "ID_Identifier",
                            ")",
                            ";",
                            "for",
                            "(",
                            "var",
                            "ID_Identifier",
                            "=",
                            "0",
                            ";",
                            "ID_Identifier",
                            "<",
                            "ID_Identifier",
                            ";",
                            "ID_Identifier"
                        ],
                        "tokens2": [
                            "ID_Identifier",
                            ",",
                            "ID_Identifier",
                            ",",
                            "ID_Identifier",
                            ";",
                            "for",
                            "(",
                            "var",
                            "ID_Identifier",
                            "=",
                            "0",
                            ";",
                            "ID_Identifier",
                            "<",
                            "ID_Identifier",
                            ";",
                            "ID_Identifier",
                            "++",
                            ")"
                        ],
                        "similarity_details": {
                            "lcs": 0.8,
                            "sequence_matcher": 0.8,
                            "ngram": 0.6111111111111112,
                            "levenshtein": 0.8992248062015504,
                            "tfidf_cosine": 0.7048900819879953,
                            "winnowing": 1
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                        "code2": "class _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }"
                    },
                    {
                        "fragment1": [
                            640,
                            760
                        ],
                        "fragment2": [
                            1110,
                            1200
                        ],
                        "similarity": 1.0000000000000002,
                        "tokens1": [
                            "var",
                            "ID_Identifier",
                            "=",
                            "ID_Identifier",
                            "+",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "(",
                            "ID_Identifier",
                            ")",
                            "+",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "(",
                            "ID_Identifier",
                            ",",
                            "ID_Identifier",
                            ","
                        ],
                        "tokens2": [
                            "ID_Identifier",
                            "]",
                            ";",
                            "var",
                            "ID_Identifier",
                            "=",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "(",
                            "ID_Identifier",
                            ")",
                            "+",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "(",
                            "ID_Identifier",
                            ",",
                            "ID_Identifier"
                        ],
                        "similarity_details": {
                            "lcs": 0.85,
                            "sequence_matcher": 0.85,
                            "ngram": 0.7777777777777778,
                            "levenshtein": 0.9060402684563759,
                            "tfidf_cosine": 0.9032400268543423,
                            "winnowing": 0.6666666666666666
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                        "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                    },
                    {
                        "fragment1": [
                            740,
                            990
                        ],
                        "fragment2": [
                            1260,
                            1430
                        ],
                        "similarity": 1.0000000000000007,
                        "tokens1": [
                            "[",
                            "0",
                            "]",
                            "=",
                            "(",
                            "ID_Identifier",
                            "[",
                            "0",
                            "]",
                            "+",
                            "ID_Identifier",
                            ")",
                            "&",
                            "0xffffffff",
                            ";",
                            "ID_Identifier",
                            "[",
                            "1",
                            "]",
                            "="
                        ],
                        "tokens2": [
                            "[",
                            "5",
                            "]",
                            "=",
                            "(",
                            "ID_Identifier",
                            "[",
                            "5",
                            "]",
                            "+",
                            "ID_Identifier",
                            ")",
                            "&",
                            "0xffffffff",
                            ";",
                            "ID_Identifier",
                            "[",
                            "6",
                            "]",
                            "="
                        ],
                        "similarity_details": {
                            "lcs": 0.85,
                            "sequence_matcher": 0.85,
                            "ngram": 0.5555555555555556,
                            "levenshtein": 0.9642857142857143,
                            "tfidf_cosine": 0.5644570020409767,
                            "winnowing": 0.3333333333333333
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                        "code2": "\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                    },
                    {
                        "fragment1": [
                            970,
                            990
                        ],
                        "fragment2": [
                            1450,
                            1470
                        ],
                        "similarity": 0.7108814122903837,
                        "tokens1": [
                            "<<",
                            "(",
                            "32",
                            "-",
                            "ID_Identifier",
                            ")",
                            ")",
                            ";",
                            "}",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ")",
                            "{",
                            "return",
                            "ID_Identifier"
                        ],
                        "tokens2": [
                            "(",
                            "22",
                            ",",
                            "ID_Identifier",
                            ")",
                            ";",
                            "}",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ")",
                            "{",
                            "return",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier"
                        ],
                        "similarity_details": {
                            "lcs": 0.8,
                            "sequence_matcher": 0.8,
                            "ngram": 0.6666666666666666,
                            "levenshtein": 0.814516129032258,
                            "tfidf_cosine": 0.7482242657529938,
                            "winnowing": 0.25
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                        "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                    },
                    {
                        "fragment1": [
                            970,
                            1000
                        ],
                        "fragment2": [
                            1490,
                            1510
                        ],
                        "similarity": 1,
                        "tokens1": [
                            "<<",
                            "(",
                            "32",
                            "-",
                            "ID_Identifier",
                            ")",
                            ")",
                            ";",
                            "}",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ")",
                            "{",
                            "return",
                            "ID_Identifier"
                        ],
                        "tokens2": [
                            ",",
                            "ID_Identifier",
                            ")",
                            ";",
                            "}",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ")",
                            "{",
                            "return",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "(",
                            "7"
                        ],
                        "similarity_details": {
                            "lcs": 0.75,
                            "sequence_matcher": 0.75,
                            "ngram": 0.6666666666666666,
                            "levenshtein": 0.7479674796747968,
                            "tfidf_cosine": 0.7482242657529938,
                            "winnowing": 0.5
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                        "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                    },
                    {
                        "fragment1": [
                            980,
                            1140
                        ],
                        "fragment2": [
                            1530,
                            1580
                        ],
                        "similarity": 1.0000000000000007,
                        "tokens1": [
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ")",
                            "{",
                            "return",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "(",
                            "2",
                            ",",
                            "ID_Identifier",
                            ")",
                            "^",
                            "ID_Identifier",
                            "."
                        ],
                        "tokens2": [
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ")",
                            "{",
                            "return",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "(",
                            "17",
                            ",",
                            "ID_Identifier",
                            ")",
                            "^",
                            "ID_Identifier"
                        ],
                        "similarity_details": {
                            "lcs": 0.9,
                            "sequence_matcher": 0.9,
                            "ngram": 0.7777777777777778,
                            "levenshtein": 0.8676470588235294,
                            "tfidf_cosine": 0.8752690307575414,
                            "winnowing": 0.6666666666666666
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                        "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                    },
                    {
                        "fragment1": [
                            1120,
                            1270
                        ],
                        "fragment2": [
                            1590,
                            1710
                        ],
                        "similarity": 1.0000000000000009,
                        "tokens1": [
                            ">>>",
                            "10",
                            ")",
                            ";",
                            "}",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ",",
                            "ID_Identifier",
                            ",",
                            "ID_Identifier",
                            ")",
                            "{",
                            "return",
                            "("
                        ],
                        "tokens2": [
                            ")",
                            ";",
                            "}",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ",",
                            "ID_Identifier",
                            ",",
                            "ID_Identifier",
                            ")",
                            "{",
                            "return",
                            "(",
                            "ID_Identifier",
                            "&"
                        ],
                        "similarity_details": {
                            "lcs": 0.9,
                            "sequence_matcher": 0.9,
                            "ngram": 0.8888888888888888,
                            "levenshtein": 0.8130081300813008,
                            "tfidf_cosine": 0.8922288908197358,
                            "winnowing": 0.5
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                        "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                    },
                    {
                        "fragment1": [
                            1250,
                            1280
                        ],
                        "fragment2": [
                            1800,
                            1830
                        ],
                        "similarity": 1,
                        "tokens1": [
                            ";",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ")",
                            "{",
                            "var",
                            "ID_Identifier",
                            "=",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "(",
                            "/[\\u0080-\\u07ff]/g",
                            ",",
                            "function"
                        ],
                        "tokens2": [
                            "}",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ")",
                            "{",
                            "var",
                            "ID_Identifier",
                            "=",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "(",
                            "/[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g",
                            ",",
                            "function"
                        ],
                        "similarity_details": {
                            "lcs": 0.9,
                            "sequence_matcher": 0.9,
                            "ngram": 0.7777777777777778,
                            "levenshtein": 0.8160919540229885,
                            "tfidf_cosine": 0.8409526812426942,
                            "winnowing": 1
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                        "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                    },
                    {
                        "fragment1": [
                            1260,
                            1440
                        ],
                        "fragment2": [
                            1880,
                            1900
                        ],
                        "similarity": 1.0000000000000007,
                        "tokens1": [
                            "var",
                            "ID_Identifier",
                            "=",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "(",
                            "/[\\u0080-\\u07ff]/g",
                            ",",
                            "function",
                            "(",
                            "ID_Identifier",
                            ")",
                            "{",
                            "var",
                            "ID_Identifier",
                            "=",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier"
                        ],
                        "tokens2": [
                            "=",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "(",
                            "/[\\u00c0-\\u00df][\\u0080-\\u00bf]/g",
                            ",",
                            "function",
                            "(",
                            "ID_Identifier",
                            ")",
                            "{",
                            "var",
                            "ID_Identifier",
                            "=",
                            "(",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "("
                        ],
                        "similarity_details": {
                            "lcs": 0.85,
                            "sequence_matcher": 0.85,
                            "ngram": 0.6111111111111112,
                            "levenshtein": 0.8157894736842105,
                            "tfidf_cosine": 0.7944040067626077,
                            "winnowing": 0.3333333333333333
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                        "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }"
                    },
                    {
                        "fragment1": [
                            1420,
                            1490
                        ],
                        "fragment2": [
                            1910,
                            1930
                        ],
                        "similarity": 1.0000000000000007,
                        "tokens1": [
                            "ID_Identifier",
                            "(",
                            "2",
                            ")",
                            "&",
                            "0x3f",
                            ")",
                            ";",
                            "return",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "(",
                            "ID_Identifier",
                            ")",
                            ";",
                            "}",
                            ")",
                            ";",
                            "ID_Identifier"
                        ],
                        "tokens2": [
                            "ID_Identifier",
                            "(",
                            "1",
                            ")",
                            "&",
                            "0x3f",
                            ";",
                            "return",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "(",
                            "ID_Identifier",
                            ")",
                            ";",
                            "}",
                            ")",
                            ";",
                            "return",
                            "ID_Identifier"
                        ],
                        "similarity_details": {
                            "lcs": 0.9,
                            "sequence_matcher": 0.9,
                            "ngram": 0.6666666666666666,
                            "levenshtein": 0.9107142857142857,
                            "tfidf_cosine": 0.8000972810214388,
                            "winnowing": 0.14285714285714285
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                        "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                    },
                    {
                        "fragment1": [
                            1890,
                            1920
                        ],
                        "fragment2": [
                            0,
                            30
                        ],
                        "similarity": 0.7493284865824371,
                        "tokens1": [
                            "]",
                            "class",
                            "ID_Identifier",
                            "{",
                            "ID_Identifier",
                            "(",
                            "ID_Identifier",
                            ",",
                            "ID_Identifier",
                            ",",
                            "ID_Identifier",
                            ",",
                            "ID_Identifier",
                            ")",
                            "{",
                            "this",
                            ".",
                            "ID_Identifier",
                            "=",
                            "ID_Identifier"
                        ],
                        "tokens2": [
                            "import",
                            "ID_Identifier",
                            "ID_Identifier",
                            "\"./linked_list.js\"",
                            ";",
                            "class",
                            "ID_Identifier",
                            "{",
                            "ID_Identifier",
                            "(",
                            "ID_Identifier",
                            ",",
                            "ID_Identifier",
                            ")",
                            "{",
                            "this",
                            ".",
                            "ID_Identifier",
                            "=",
                            "ID_Identifier"
                        ],
                        "similarity_details": {
                            "lcs": 0.75,
                            "sequence_matcher": 0.75,
                            "ngram": 0.7222222222222222,
                            "levenshtein": 0.774390243902439,
                            "tfidf_cosine": 0.8006727504796005,
                            "winnowing": 0.5
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                        "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                    },
                    {
                        "fragment1": [
                            2490,
                            2510
                        ],
                        "fragment2": [
                            390,
                            410
                        ],
                        "similarity": 0.7149783475176564,
                        "tokens1": [
                            "ID_Identifier",
                            "(",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "+",
                            "\" Es el Hash\"",
                            ")",
                            "this",
                            ".",
                            "ID_Identifier",
                            "(",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            ")",
                            "this",
                            ".",
                            "ID_Identifier",
                            "("
                        ],
                        "tokens2": [
                            "this",
                            ".",
                            "ID_Identifier",
                            "(",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            ")",
                            ";",
                            "this",
                            ".",
                            "ID_Identifier",
                            "(",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            ")",
                            ";",
                            "if",
                            "("
                        ],
                        "similarity_details": {
                            "lcs": 0.75,
                            "sequence_matcher": 0.6,
                            "ngram": 0.6111111111111112,
                            "levenshtein": 0.7163120567375887,
                            "tfidf_cosine": 0.7349685697395825,
                            "winnowing": 1
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                        "code2": "import LinkedList from \"./linked_list.js\";\n\nclass _Node{\n    constructor(data,id){\n        this.data = data;\n        this.left = this.right = null;\n        this.id = `n${id}`;\n    }\n}\n\nexport default class MerkleTree{\n    constructor(){\n        this.root = null;\n        this.dataBlocks = null;\n        this.curr_block = null;\n        this.junkBlocks = null;\n        this.id = 0;\n    }\n    _fillDataBlocks(){\n        //get a power of 2 greater than number of data blocks\n        let n = 1;\n        let powerOf2 = Math.pow(2,n);\n        while(powerOf2 < this.dataBlocks.len){\n            n++;\n            powerOf2 = Math.pow(2,n);\n        }\n        //fill data blocks until lenght = powerOf2\n        this.junkBlocks = new LinkedList();\n        for (let i = this.dataBlocks.len; i < powerOf2; i++) {\n            this.junkBlocks.add(i*100);\n        }\n        return n;\n    }\n    genTree(list){\n        if(list.isEmpty()){\n            this.dataBlocks = list;\n            this.curr_block = this.dataBlocks.head;\n            const exp = this._fillDataBlocks();\n            this.root = new _Node(null, this.id++);\n            this._genTreeRec(this.root, exp);\n            this._genHash(this.root);\n        }\n    }\n    _genTreeRec(root, exp){\n        //pre order traversal\n        if(exp > 0){\n            root.left = new _Node(null, this.id++);\n            root.right = new _Node(null, this.id++);\n            this._genTreeRec(root.left, exp-1);\n            this._genTreeRec(root.right, exp-1);\n        }\n        //fill the last level with the hashes of the data blocks\n        else{\n            root.data = Sha256.hash(this.curr_block.data.toString());\n            if(this.curr_block.next){\n                this.curr_block = this.curr_block.next;\n            }\n            else{\n                this.curr_block = this.junkBlocks.head;\n            }\n        }\n    }\n    _genHash(root){\n        //post order traversal\n        if(root == null){\n            return;\n        }\n        this._genHash(root.left);\n        this._genHash(root.right);\n        //If the node's data is null, generate a hash for it\n        if(!root.data){\n            root.data = Sha256.hash(root.left.data + root.right.data);\n        }\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                    }
                ],
                "ml_fragments": [
                    {
                        "type": "ml_block",
                        "block1": {
                            "start_line": 0,
                            "end_line": 50,
                            "code": "var Sha256 = {}; Sha256.hash = function (msg, utf8encode) { utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode; if (utf8encode) msg = Utf8.encode(msg); var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]; var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]; msg += String.fromCharCode(0x80); var l = msg.length / 4 + 2; var N = Math.ceil(l / 16); var M = new Array(N); for (var i = 0; i < N; i++) { M[i] = new Array(16); for (var j = 0; j < 16; j++) { M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) | (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3)); } } M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14]) M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff; var W = new Array(64); var a, b, c, d, e, f, g, h; for (var i = 0; i < N; i++) { for (var t = 0; t < 16; t++) W[t] = M[i][t]; for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff; a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7]; for (var t = 0; t < 64; t++) { var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t]; var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c); h = g; g = f; f = e; e = (d + T1) & 0xffffffff; d = c; c = b; b = a; a = (T1 + T2) & 0xffffffff; } H[0] = (H[0] + a) & 0xffffffff; H[1] = (H[1] + b) & 0xffffffff; H[2] = (H[2] + c) & 0xffffffff; H[3] = (H[3] + d) & 0xffffffff; H[4] = (H[4] + e) & 0xffffffff; H[5] = (H[5] + f) & 0xffffffff; H[6] = (H[6] + g) & 0xffffffff; H[7] = (H[7] + h) & 0xffffffff; } return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) + Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]); } Sha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); } Sha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); } Sha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); } Sha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); } Sha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); } Sha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); } Sha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); } Sha256.toHexStr = function (n) { var s = \"\", v; for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); } return s; } var Utf8 = {}; Utf8.encode = function (strUni) { var strUtf = strUni.replace( /[\\u0080-\\u07ff]/g, function (c) { var cc = c.charCodeAt(0); return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f); } ); strUtf = strUtf.replace( /[\\u0800-\\uffff]/g, function (c) { var cc = c.charCodeAt(0); return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f); } ); return strUtf; } Utf8.decode = function (strUtf) { var strUni = strUtf.replace( /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g, function (c) { var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f); return String.fromCharCode(cc); } ); strUni = strUni.replace( /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g, function (c) { var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f; return String.fromCharCode(cc); } ); return strUni; } class NodoListaTemporal { constructor(datTemporal) { this.datTemporal = datTemporal this.siguiente = null this.anterior = null } } var contadorglobal = 0 var salida = \"\" class ListaTemporal { constructor() { this.cabeza = null this.cola = null this.size = 0 } insertLista(dato) { let nodo = new NodoListaTemporal(dato); if (this.cabeza == null) { this.cabeza = nodo; this.cola = nodo; this.size++; } else if (this.cabeza != null) { let aux = this.cabeza; while (aux != this.cola) { aux = aux.siguiente; } aux.siguiente = nodo; nodo.anterior = aux this.cola = nodo; this.size++; } } eliminarLista(dato) { let nodo = this.cabeza if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) { this.cabeza = null this.cola = null this.size = 0 return } while (nodo.datTemporal != dato && nodo != this.cola) { nodo = nodo.siguiente } if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) { let tmp = nodo.siguiente this.cabeza = tmp tmp.anterior = null nodo.siguiente = null this.size-- return } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) { let tmp = nodo.siguiente tmp.anterior = nodo.anterior nodo.anterior.siguiente = tmp nodo.siguiente = null nodo.anterior = null this.size-- return } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) { let tmp = nodo.anterior this.cola = tmp tmp.siguiente = null nodo.anterior = null this.size-- return } if (nodo == null) { console.log(\"No se encontro el dato a eliminar\") return } } } var recarga = [] class Nodo { constructor(dato, izquierda, derecha, nodohijo) { this.dato = dato this.hash = null this.id = 0 this.nodohijo = nodohijo this.izquierda = izquierda this.derecha = derecha } } class MerkleTree { constructor() { this.raiz = null } insertar(dato) { let nodo = new Nodo(dato, null, null, true) if (this.raiz == null) { let listatmp = new ListaTemporal() listatmp.insertLista(nodo) listatmp.insertLista(new Nodo(-1, null, null, true)) this.construirArbol(listatmp) } else { let listatmp = this.ObtenerLista() listatmp.insertLista(nodo) this.construirArbol(listatmp) } this.hashing() contadorglobal = 0 } ObtenerLista() { let listatmp = new ListaTemporal() this.obtenerlista(listatmp, this.raiz.izquierda) this.obtenerlista(listatmp, this.raiz.derecha) return listatmp } obtenerlista(lista, nodo) { if (nodo != null) { this.obtenerlista(lista, nodo.izquierda) if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) { lista.insertLista(nodo) } this.obtenerlista(lista, nodo.derecha) } } construirArbol(lista) { let tamanio = new Float64Array(lista.size) let cant = 1 let operacion = tamanio.length / 2 while (operacion > 1) { cant++ operacion = operacion / 2 } let vectorTotal = new Float64Array(cant) let totalnodos = Math.pow(2, vectorTotal.length) while (lista.size < Math.floor(totalnodos)) { lista.insertLista(new Nodo(-1, null, null, true)) } while (lista.size > 1) { let primero = lista.cabeza let segundo = primero.siguiente lista.eliminarLista(primero.datTemporal) lista.eliminarLista(segundo.datTemporal) let nodo1 = primero.datTemporal nodo1.id = contadorglobal + 1 let nodo2 = segundo.datTemporal nodo2.id = contadorglobal + 2 let suma = nodo1.dato + nodo2.dato let nuevo = new Nodo(suma, nodo1, nodo2, false) nuevo.id = contadorglobal lista.insertLista(nuevo) contadorglobal = contadorglobal + 3 } this.raiz = lista.cabeza.datTemporal } hashing() { if (this.raiz == null) { console.log(\"No existe arbol\") return } this.subHashing(this.raiz) } subHashing(nodo) { if (nodo != null) { let hasheo = Sha256.hash(String(nodo.dato)) nodo.hash = hasheo this.subHashing(nodo.izquierda) this.subHashing(nodo.derecha) } } imprimiendo() { if (this.raiz == null) { console.log(\"No existe arbol\") return } this.imprimir(this.raiz) } imprimir(nodo) { if (nodo != null) { console.log(nodo.dato + \" Es el dato\") console.log(nodo.hash + \" Es el Hash\") this.imprimir(nodo.izquierda) this.imprimir(nodo.derecha) } } preOrden(nodo, vector) { if (nodo != null) { vector.push(nodo.dato) this.preOrden(nodo.izquierda, vector) this.preOrden(nodo.derecha, vector) } return vector } graficar(valorBuscar) { salida = \"\" if (this.raiz == null) { console.log(\"No hay nada aun\") return } let nodo = this.raiz let contador = 0 salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\" this.graficando(nodo, valorBuscar) salida += \"}\" contador = 0 d3.select(' .width(750) .height(400) .renderDot(salida) return console.log(salida) } graficando(nodo, valorBuscar) { if (nodo != null) { if (valorBuscar == nodo.dato) { salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\" \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\" } else { salida += \"node\" + nodo.id + \" [label = \\\" \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\" } if (nodo.derecha != null) { salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\" } if (nodo.izquierda != null) { salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\" } if (nodo.izquierda != null) { this.graficando(nodo.izquierda, valorBuscar) } if (nodo.derecha != null) { this.graficando(nodo.derecha, valorBuscar) } } } getMerkleRoot() { return this.raiz.hash } } let Transacciones = new MerkleTree() Transacciones.graficar(0)"
                        },
                        "block2": {
                            "start_line": 0,
                            "end_line": 50,
                            "code": "import LinkedList from \"./linked_list.js\"; class _Node{ constructor(data,id){ this.data = data; this.left = this.right = null; this.id = `n${id}`; } } export default class MerkleTree{ constructor(){ this.root = null; this.dataBlocks = null; this.curr_block = null; this.junkBlocks = null; this.id = 0; } _fillDataBlocks(){ let n = 1; let powerOf2 = Math.pow(2,n); while(powerOf2 < this.dataBlocks.len){ n++; powerOf2 = Math.pow(2,n); } this.junkBlocks = new LinkedList(); for (let i = this.dataBlocks.len; i < powerOf2; i++) { this.junkBlocks.add(i*100); } return n; } genTree(list){ if(list.isEmpty()){ this.dataBlocks = list; this.curr_block = this.dataBlocks.head; const exp = this._fillDataBlocks(); this.root = new _Node(null, this.id++); this._genTreeRec(this.root, exp); this._genHash(this.root); } } _genTreeRec(root, exp){ if(exp > 0){ root.left = new _Node(null, this.id++); root.right = new _Node(null, this.id++); this._genTreeRec(root.left, exp-1); this._genTreeRec(root.right, exp-1); } else{ root.data = Sha256.hash(this.curr_block.data.toString()); if(this.curr_block.next){ this.curr_block = this.curr_block.next; } else{ this.curr_block = this.junkBlocks.head; } } } _genHash(root){ if(root == null){ return; } this._genHash(root.left); this._genHash(root.right); if(!root.data){ root.data = Sha256.hash(root.left.data + root.right.data); } } } var Sha256 = {}; Sha256.hash = function (msg, utf8encode) { utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode; if (utf8encode) msg = Utf8.encode(msg); var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]; var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]; msg += String.fromCharCode(0x80); var l = msg.length / 4 + 2; var N = Math.ceil(l / 16); var M = new Array(N); for (var i = 0; i < N; i++) { M[i] = new Array(16); for (var j = 0; j < 16; j++) { M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) | (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3)); } } M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14]) M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff; var W = new Array(64); var a, b, c, d, e, f, g, h; for (var i = 0; i < N; i++) { for (var t = 0; t < 16; t++) W[t] = M[i][t]; for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff; a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7]; for (var t = 0; t < 64; t++) { var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t]; var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c); h = g; g = f; f = e; e = (d + T1) & 0xffffffff; d = c; c = b; b = a; a = (T1 + T2) & 0xffffffff; } H[0] = (H[0] + a) & 0xffffffff; H[1] = (H[1] + b) & 0xffffffff; H[2] = (H[2] + c) & 0xffffffff; H[3] = (H[3] + d) & 0xffffffff; H[4] = (H[4] + e) & 0xffffffff; H[5] = (H[5] + f) & 0xffffffff; H[6] = (H[6] + g) & 0xffffffff; H[7] = (H[7] + h) & 0xffffffff; } return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) + Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]); } Sha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); } Sha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); } Sha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); } Sha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); } Sha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); } Sha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); } Sha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); } Sha256.toHexStr = function (n) { var s = \"\", v; for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); } return s; } var Utf8 = {}; Utf8.encode = function (strUni) { var strUtf = strUni.replace( /[\\u0080-\\u07ff]/g, function (c) { var cc = c.charCodeAt(0); return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f); } ); strUtf = strUtf.replace( /[\\u0800-\\uffff]/g, function (c) { var cc = c.charCodeAt(0); return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f); } ); return strUtf; } Utf8.decode = function (strUtf) { var strUni = strUtf.replace( /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g, function (c) { var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f); return String.fromCharCode(cc); } ); strUni = strUni.replace( /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g, function (c) { var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f; return String.fromCharCode(cc); } ); return strUni; }"
                        },
                        "similarity": 0.7826109736901622,
                        "similarity_details": {
                            "tfidf": 0.8135298074469223,
                            "char_ngram": 0.70211477395347,
                            "word_ngram": 0.46817214646738037,
                            "embedding": 0.9646190404891968
                        }
                    }
                ],
                "is_plagiarism": false,
                "plagiarism_probability": 0.6953369351452039,
                "all_features": {
                    "lcs": 0.5259076489249207,
                    "sequence_matcher": 0.6257076955336549,
                    "ngram": 0.7492130115424974,
                    "levenshtein": 0.5059020946649693,
                    "tfidf_cosine": 0.9787062770831157,
                    "winnowing": 0.6194968553459119,
                    "ml_tfidf": 0.8135298074469223,
                    "ml_char_ngram": 0.70211477395347,
                    "ml_word_ngram": 0.46817214646738037,
                    "ml_embedding": 0.9646190404891968
                }
            },
            {
                "file1": {
                    "submission": "extracted_-EDD_junio-Proyecto2_201800992-main",
                    "path": "-EDD_junio-Proyecto2_201800992-main\\js\\Arboles\\arbolMerkle.js",
                    "full_path": "C:\\Users\\gian-\\AppData\\Local\\Temp\\plagiarism_checker\\323c8304-f54c-4baa-a6a4-eefec5065d1f\\extracted_-EDD_junio-Proyecto2_201800992-main\\-EDD_junio-Proyecto2_201800992-main\\js\\Arboles\\arbolMerkle.js"
                },
                "file2": {
                    "submission": "extracted_-EDD_junio-Proyecto2_201801178-main",
                    "path": "-EDD_junio-Proyecto2_201801178-main\\src\\data_structs\\block.js",
                    "full_path": "C:\\Users\\gian-\\AppData\\Local\\Temp\\plagiarism_checker\\323c8304-f54c-4baa-a6a4-eefec5065d1f\\extracted_-EDD_junio-Proyecto2_201801178-main\\-EDD_junio-Proyecto2_201801178-main\\src\\data_structs\\block.js"
                },
                "token_similarity": 0.6657556641443445,
                "token_similarity_details": {
                    "lcs": 0.5259076489249207,
                    "sequence_matcher": 0.6478506296135476,
                    "ngram": 0.7153411560191221,
                    "levenshtein": 0.4693322532114339,
                    "tfidf_cosine": 0.9678360468240756,
                    "winnowing": 0.5919003115264797
                },
                "ml_similarity": 0.7832133332332992,
                "ml_similarity_details": {
                    "tfidf": 0.8028736418297481,
                    "char_ngram": 0.6825066322237517,
                    "word_ngram": 0.48358712367656415,
                    "embedding": 0.9735496044158936
                },
                "combined_similarity": 0.7127387317799264,
                "similar_fragments": [
                    {
                        "fragment1": [
                            0,
                            20
                        ],
                        "fragment2": [
                            280,
                            300
                        ],
                        "similarity": 0.7727474779549475,
                        "tokens1": [
                            "var",
                            "ID_Identifier",
                            "=",
                            "{",
                            "}",
                            ";",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ",",
                            "ID_Identifier",
                            ")",
                            "{",
                            "ID_Identifier",
                            "=",
                            "("
                        ],
                        "tokens2": [
                            "{",
                            "}",
                            ";",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ",",
                            "ID_Identifier",
                            ")",
                            "{",
                            "ID_Identifier",
                            "=",
                            "(",
                            "typeof",
                            "ID_Identifier",
                            "=="
                        ],
                        "similarity_details": {
                            "lcs": 0.85,
                            "sequence_matcher": 0.85,
                            "ngram": 0.8333333333333334,
                            "levenshtein": 0.6451612903225806,
                            "tfidf_cosine": 0.8602427661188232,
                            "winnowing": 0.5
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                        "code2": "import LinkedList from \"../data_structs/linked_list.js\";\n\nclass _Block{\n    constructor({\n        index,\n        timeStamp,\n        prevHash,\n        rootMerkle,\n        data,\n    }){\n        this.index = index;\n        this.timeStamp = timeStamp;\n        this.prevHash = prevHash;\n        this.rootMerkle = rootMerkle;\n        this.data = data;\n        this.hash = this._genHash();\n        this.nonce = 0;\n        this._proofOfWork();\n    }\n    _proofOfWork(){\n        while(!this.hash.startsWith('00')){\n            this.nonce++;\n            this.hash = this._genHash();\n        }\n    }\n    _genHash(){\n        return Sha256.hash(this.index+this.timeStamp+this.prevHash+this.root+this.nonce);\n    }\n    toString(){\n        return `\n        bloque: ${this.index}\\\\n\n        hash: ${this.hash}\\\\n\n        nonce: ${this.nonce}\\\\n\n        prev: ${this.prevHash}\\\\n\n        rootMerkle: ${this.rootMerkle}\\\\n\n        transacciones:\\\\n\n        ${this.data}\n        timeStamp: ${this.timeStamp}\n        `;\n    }\n}\n\nexport default class BlockChain{\n    constructor(){\n        this.blocks = new LinkedList();\n        this.index = 0;\n    }\n    genNewBlock(timeStamp, root, list){\n        const data = {\n            index: this.index++,\n            timeStamp: timeStamp,\n            prevHash: (this.blocks.isEmpty()) ? this.blocks.end.data.hash : '',\n            rootMerkle: root,\n            data: list,\n        };\n        this.blocks.add(new _Block(data));\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                    },
                    {
                        "fragment1": [
                            0,
                            1200
                        ],
                        "fragment2": [
                            1520,
                            1540
                        ],
                        "similarity": 0.9412181204694048,
                        "tokens1": [
                            "var",
                            "ID_Identifier",
                            "=",
                            "{",
                            "}",
                            ";",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ",",
                            "ID_Identifier",
                            ")",
                            "{",
                            "ID_Identifier",
                            "=",
                            "("
                        ],
                        "tokens2": [
                            ";",
                            "}",
                            "var",
                            "ID_Identifier",
                            "=",
                            "{",
                            "}",
                            ";",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ")",
                            "{",
                            "var",
                            "ID_Identifier",
                            "="
                        ],
                        "similarity_details": {
                            "lcs": 0.85,
                            "sequence_matcher": 0.85,
                            "ngram": 0.6666666666666666,
                            "levenshtein": 0.8083333333333333,
                            "tfidf_cosine": 0.8000834850559742,
                            "winnowing": 0.25
                        },
                        "code1": "\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                        "code2": "import LinkedList from \"../data_structs/linked_list.js\";\n\nclass _Block{\n    constructor({\n        index,\n        timeStamp,\n        prevHash,\n        rootMerkle,\n        data,\n    }){\n        this.index = index;\n        this.timeStamp = timeStamp;\n        this.prevHash = prevHash;\n        this.rootMerkle = rootMerkle;\n        this.data = data;\n        this.hash = this._genHash();\n        this.nonce = 0;\n        this._proofOfWork();\n    }\n    _proofOfWork(){\n        while(!this.hash.startsWith('00')){\n            this.nonce++;\n            this.hash = this._genHash();\n        }\n    }\n    _genHash(){\n        return Sha256.hash(this.index+this.timeStamp+this.prevHash+this.root+this.nonce);\n    }\n    toString(){\n        return `\n        bloque: ${this.index}\\\\n\n        hash: ${this.hash}\\\\n\n        nonce: ${this.nonce}\\\\n\n        prev: ${this.prevHash}\\\\n\n        rootMerkle: ${this.rootMerkle}\\\\n\n        transacciones:\\\\n\n        ${this.data}\n        timeStamp: ${this.timeStamp}\n        `;\n    }\n}\n\nexport default class BlockChain{\n    constructor(){\n        this.blocks = new LinkedList();\n        this.index = 0;\n    }\n    genNewBlock(timeStamp, root, list){\n        const data = {\n            index: this.index++,\n            timeStamp: timeStamp,\n            prevHash: (this.blocks.isEmpty()) ? this.blocks.end.data.hash : '',\n            rootMerkle: root,\n            data: list,\n        };\n        this.blocks.add(new _Block(data));\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                    },
                    {
                        "fragment1": [
                            1180,
                            1320
                        ],
                        "fragment2": [
                            1630,
                            1660
                        ],
                        "similarity": 0.9407070962311863,
                        "tokens1": [
                            "ID_Identifier",
                            "&",
                            "ID_Identifier",
                            ")",
                            ";",
                            "}",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ")",
                            "{",
                            "var",
                            "ID_Identifier",
                            "=",
                            "\"\"",
                            ","
                        ],
                        "tokens2": [
                            ";",
                            "}",
                            ")",
                            ";",
                            "return",
                            "ID_Identifier",
                            ";",
                            "}",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "=",
                            "function",
                            "(",
                            "ID_Identifier",
                            ")",
                            "{",
                            "var",
                            "ID_Identifier",
                            "="
                        ],
                        "similarity_details": {
                            "lcs": 0.75,
                            "sequence_matcher": 0.75,
                            "ngram": 0.6666666666666666,
                            "levenshtein": 0.8264462809917356,
                            "tfidf_cosine": 0.7380386116058992,
                            "winnowing": 0.5
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                        "code2": "import LinkedList from \"../data_structs/linked_list.js\";\n\nclass _Block{\n    constructor({\n        index,\n        timeStamp,\n        prevHash,\n        rootMerkle,\n        data,\n    }){\n        this.index = index;\n        this.timeStamp = timeStamp;\n        this.prevHash = prevHash;\n        this.rootMerkle = rootMerkle;\n        this.data = data;\n        this.hash = this._genHash();\n        this.nonce = 0;\n        this._proofOfWork();\n    }\n    _proofOfWork(){\n        while(!this.hash.startsWith('00')){\n            this.nonce++;\n            this.hash = this._genHash();\n        }\n    }\n    _genHash(){\n        return Sha256.hash(this.index+this.timeStamp+this.prevHash+this.root+this.nonce);\n    }\n    toString(){\n        return `\n        bloque: ${this.index}\\\\n\n        hash: ${this.hash}\\\\n\n        nonce: ${this.nonce}\\\\n\n        prev: ${this.prevHash}\\\\n\n        rootMerkle: ${this.rootMerkle}\\\\n\n        transacciones:\\\\n\n        ${this.data}\n        timeStamp: ${this.timeStamp}\n        `;\n    }\n}\n\nexport default class BlockChain{\n    constructor(){\n        this.blocks = new LinkedList();\n        this.index = 0;\n    }\n    genNewBlock(timeStamp, root, list){\n        const data = {\n            index: this.index++,\n            timeStamp: timeStamp,\n            prevHash: (this.blocks.isEmpty()) ? this.blocks.end.data.hash : '',\n            rootMerkle: root,\n            data: list,\n        };\n        this.blocks.add(new _Block(data));\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                    },
                    {
                        "fragment1": [
                            1300,
                            1480
                        ],
                        "fragment2": [
                            1710,
                            1760
                        ],
                        "similarity": 0.8763965607972026,
                        "tokens1": [
                            ")",
                            ";",
                            "}",
                            ")",
                            ";",
                            "ID_Identifier",
                            "=",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "(",
                            "/[\\u0800-\\uffff]/g",
                            ",",
                            "function",
                            "(",
                            "ID_Identifier",
                            ")",
                            "{",
                            "var",
                            "ID_Identifier"
                        ],
                        "tokens2": [
                            "ID_Identifier",
                            ")",
                            ";",
                            "}",
                            ")",
                            ";",
                            "ID_Identifier",
                            "=",
                            "ID_Identifier",
                            ".",
                            "ID_Identifier",
                            "(",
                            "/[\\u00c0-\\u00df][\\u0080-\\u00bf]/g",
                            ",",
                            "function",
                            "(",
                            "ID_Identifier",
                            ")",
                            "{",
                            "var"
                        ],
                        "similarity_details": {
                            "lcs": 0.9,
                            "sequence_matcher": 0.9,
                            "ngram": 0.7777777777777778,
                            "levenshtein": 0.6642857142857144,
                            "tfidf_cosine": 0.8426362202458457,
                            "winnowing": 0.3333333333333333
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                        "code2": "import LinkedList from \"../data_structs/linked_list.js\";\n\nclass _Block{\n    constructor({\n        index,\n        timeStamp,\n        prevHash,\n        rootMerkle,\n        data,\n    }){\n        this.index = index;\n        this.timeStamp = timeStamp;\n        this.prevHash = prevHash;\n        this.rootMerkle = rootMerkle;\n        this.data = data;\n        this.hash = this._genHash();\n        this.nonce = 0;\n        this._proofOfWork();\n    }\n    _proofOfWork(){\n        while(!this.hash.startsWith('00')){\n            this.nonce++;\n            this.hash = this._genHash();\n        }\n    }\n    _genHash(){\n        return Sha256.hash(this.index+this.timeStamp+this.prevHash+this.root+this.nonce);\n    }\n    toString(){\n        return `\n        bloque: ${this.index}\\\\n\n        hash: ${this.hash}\\\\n\n        nonce: ${this.nonce}\\\\n\n        prev: ${this.prevHash}\\\\n\n        rootMerkle: ${this.rootMerkle}\\\\n\n        transacciones:\\\\n\n        ${this.data}\n        timeStamp: ${this.timeStamp}\n        `;\n    }\n}\n\nexport default class BlockChain{\n    constructor(){\n        this.blocks = new LinkedList();\n        this.index = 0;\n    }\n    genNewBlock(timeStamp, root, list){\n        const data = {\n            index: this.index++,\n            timeStamp: timeStamp,\n            prevHash: (this.blocks.isEmpty()) ? this.blocks.end.data.hash : '',\n            rootMerkle: root,\n            data: list,\n        };\n        this.blocks.add(new _Block(data));\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                    },
                    {
                        "fragment1": [
                            1570,
                            1590
                        ],
                        "fragment2": [
                            20,
                            60
                        ],
                        "similarity": 0.7881012364506065,
                        "tokens1": [
                            "{",
                            "this",
                            ".",
                            "ID_Identifier",
                            "=",
                            "ID_Identifier",
                            ";",
                            "this",
                            ".",
                            "ID_Identifier",
                            "=",
                            "ID_Identifier",
                            ";",
                            "this",
                            ".",
                            "ID_Identifier",
                            "++",
                            ";",
                            "}",
                            "else"
                        ],
                        "tokens2": [
                            ",",
                            "}",
                            ")",
                            "{",
                            "this",
                            ".",
                            "ID_Identifier",
                            "=",
                            "ID_Identifier",
                            ";",
                            "this",
                            ".",
                            "ID_Identifier",
                            "=",
                            "ID_Identifier",
                            ";",
                            "this",
                            ".",
                            "ID_Identifier",
                            "="
                        ],
                        "similarity_details": {
                            "lcs": 0.8,
                            "sequence_matcher": 0.8,
                            "ngram": 0.7777777777777778,
                            "levenshtein": 0.8482142857142857,
                            "tfidf_cosine": 0.864514118760969,
                            "winnowing": 0.5
                        },
                        "code1": "/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}\n\n\n//Clase Nodo para lista temporal de carga de datos\nclass NodoListaTemporal {\n    //Constructor   \n    constructor(datTemporal) {\n        this.datTemporal = datTemporal\n        this.siguiente = null\n        this.anterior = null\n    }\n}\n\nvar contadorglobal = 0\nvar salida = \"\"\n\n//Clase Lista temporal para carga de datos\nclass ListaTemporal {\n    //Constructor\n    constructor() {\n        this.cabeza = null\n        this.cola = null\n        this.size = 0\n    }\n\n    //Metodo Insertar en lista temporal\n    insertLista(dato) {\n        let nodo = new NodoListaTemporal(dato);\n        //Insercion de primer nodo\n        if (this.cabeza == null) {\n            this.cabeza = nodo;\n            this.cola = nodo;\n            this.size++;\n        } else if (this.cabeza != null) { // Insercion de nodo No Cabeza\n            let aux = this.cabeza;\n            while (aux != this.cola) {\n                aux = aux.siguiente;\n            }\n            aux.siguiente = nodo;\n            nodo.anterior = aux\n            this.cola = nodo;\n            this.size++;\n        }\n    }\n\n    //Metodo Eliminar par alista temporal\n    eliminarLista(dato) {\n        let nodo = this.cabeza\n        if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) {\n            //Dato unico eliminado\n            this.cabeza = null\n            this.cola = null\n            this.size = 0\n            return\n        }\n        while (nodo.datTemporal != dato && nodo != this.cola) {\n            nodo = nodo.siguiente\n        }\n        if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) {\n            //Dato Eliminado en el al inicio\n            let tmp = nodo.siguiente\n            this.cabeza = tmp\n            tmp.anterior = null\n            nodo.siguiente = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) {\n            //Dato Eliminado en el centro\n            let tmp = nodo.siguiente\n            tmp.anterior = nodo.anterior\n            nodo.anterior.siguiente = tmp\n            nodo.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) {\n            //Dato eliminado al final de la lista\n            let tmp = nodo.anterior\n            this.cola = tmp\n            tmp.siguiente = null\n            nodo.anterior = null\n            this.size--\n            return\n        }\n        if (nodo == null) {\n            //Dato no encontrado\n            console.log(\"No se encontro el dato a eliminar\")\n            return\n        }\n    }\n}\n\n//arreglo para reestructuracion de datos\nvar recarga = []\n\n//Clase Nodo para arbol merkle\nclass Nodo {\n    //Constructor\n    constructor(dato, izquierda, derecha, nodohijo) {\n        this.dato = dato\n        this.hash = null\n        this.id = 0\n        this.nodohijo = nodohijo\n        this.izquierda = izquierda\n        this.derecha = derecha\n    }\n}\n\n//Clase Arbol Merkle\nclass MerkleTree {\n    //Constructor\n    constructor() {\n        this.raiz = null\n    }\n\n    //Metodo Insertar en arbol Merkle\n    insertar(dato) {\n        let nodo = new Nodo(dato, null, null, true)\n        //Insercion de primer nodo\n        if (this.raiz == null) {\n            let listatmp = new ListaTemporal()\n            listatmp.insertLista(nodo)\n            listatmp.insertLista(new Nodo(-1, null, null, true))\n            this.construirArbol(listatmp)\n        } else {  //Insercion de Nodo no primero\n            let listatmp = this.ObtenerLista()\n            listatmp.insertLista(nodo)\n            this.construirArbol(listatmp)\n        }\n        //Hasheo de datos en sha256\n        this.hashing()\n        contadorglobal = 0\n    }\n\n    //Metodo de Carga de datos en lista temporal para insercion de arbol\n    ObtenerLista() {\n        let listatmp = new ListaTemporal()\n        this.obtenerlista(listatmp, this.raiz.izquierda)\n        this.obtenerlista(listatmp, this.raiz.derecha)\n        return listatmp\n    }\n\n    //Sub metodo de carga de datos en lista temporal para insercion de arbol\n    obtenerlista(lista, nodo) {\n        if (nodo != null) {\n            this.obtenerlista(lista, nodo.izquierda)\n            if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) {\n                lista.insertLista(nodo)\n            }\n            this.obtenerlista(lista, nodo.derecha)\n        }\n    }\n\n    //Metodo para armado base de arbol\n    construirArbol(lista) {\n        let tamanio = new Float64Array(lista.size)\n        let cant = 1\n        let operacion = tamanio.length / 2\n        //Calculo de nodos actuales\n        while (operacion > 1) {\n            cant++\n            operacion = operacion / 2\n        }\n        let vectorTotal = new Float64Array(cant)\n        let totalnodos = Math.pow(2, vectorTotal.length)    //Calculo de nodos hijos para arbol merkle\n        //Complemetacion de nodos hijo para arbol merkle final\n        while (lista.size < Math.floor(totalnodos)) {\n            lista.insertLista(new Nodo(-1, null, null, true))\n        }\n        //Insercion de datos en arbol\n        while (lista.size > 1) {\n            let primero = lista.cabeza\n            let segundo = primero.siguiente\n            lista.eliminarLista(primero.datTemporal)\n            lista.eliminarLista(segundo.datTemporal)\n            let nodo1 = primero.datTemporal\n            nodo1.id = contadorglobal + 1\n            let nodo2 = segundo.datTemporal\n            nodo2.id = contadorglobal + 2\n            let suma = nodo1.dato + nodo2.dato\n            let nuevo = new Nodo(suma, nodo1, nodo2, false)\n            nuevo.id = contadorglobal\n            lista.insertLista(nuevo)\n            contadorglobal = contadorglobal + 3\n        }\n        //Asignacion de raiz\n        this.raiz = lista.cabeza.datTemporal\n    }\n\n    //Metodo Asignacion de Hash\n    hashing() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.subHashing(this.raiz)\n    }\n\n    //SubMetodo Asignacion de Hash\n    subHashing(nodo) {\n        if (nodo != null) {\n            let hasheo = Sha256.hash(String(nodo.dato))\n            nodo.hash = hasheo\n            this.subHashing(nodo.izquierda)\n            this.subHashing(nodo.derecha)\n        }\n    }\n\n    //Metodo Imprimir\n    imprimiendo() {\n        if (this.raiz == null) {\n            console.log(\"No existe arbol\")\n            return\n        }\n        this.imprimir(this.raiz)\n    }\n\n    //SubMetodo Imprimir\n    imprimir(nodo) {\n        if (nodo != null) {\n            console.log(nodo.dato + \" Es el dato\")\n            console.log(nodo.hash + \" Es el Hash\")\n            this.imprimir(nodo.izquierda)\n            this.imprimir(nodo.derecha)\n        }\n    }\n\n\n\n\n\n    preOrden(nodo, vector) {\n        if (nodo != null) {\n            vector.push(nodo.dato)\n            this.preOrden(nodo.izquierda, vector)\n            this.preOrden(nodo.derecha, vector)\n        }\n        return vector\n    }\n\n\n    //Metodo Graficar\n    graficar(valorBuscar) {\n\n        salida = \"\"\n        if (this.raiz == null) {\n            console.log(\"No hay nada aun\")\n            return\n        }\n        let nodo = this.raiz\n        let contador = 0\n        salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\"\n        this.graficando(nodo, valorBuscar)\n        salida += \"}\"\n        \n        contador = 0\n        d3.select('#merkle').graphviz()\n        .width(750)\n        .height(400)\n        .renderDot(salida) \n\n        return console.log(salida)\n    }\n\n    //SubMetodo Buscar\n    graficando(nodo, valorBuscar) {\n        if (nodo != null) {\n            if (valorBuscar == nodo.dato) {\n                salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\"\n            } else {\n                salida += \"node\" + nodo.id + \" [label = \\\"  \" + nodo.dato + \"|\" + nodo.hash + \"  \\\"]; \\n\"\n            }\n            if (nodo.derecha != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\"\n            }\n            if (nodo.izquierda != null) {\n                this.graficando(nodo.izquierda, valorBuscar)\n            }\n            if (nodo.derecha != null) {\n                this.graficando(nodo.derecha, valorBuscar)\n            }\n        }\n\n    }\n\n    getMerkleRoot() {\n        return  this.raiz.hash\n    }\n}\n\nlet Transacciones = new MerkleTree()\nTransacciones.graficar(0)",
                        "code2": "import LinkedList from \"../data_structs/linked_list.js\";\n\nclass _Block{\n    constructor({\n        index,\n        timeStamp,\n        prevHash,\n        rootMerkle,\n        data,\n    }){\n        this.index = index;\n        this.timeStamp = timeStamp;\n        this.prevHash = prevHash;\n        this.rootMerkle = rootMerkle;\n        this.data = data;\n        this.hash = this._genHash();\n        this.nonce = 0;\n        this._proofOfWork();\n    }\n    _proofOfWork(){\n        while(!this.hash.startsWith('00')){\n            this.nonce++;\n            this.hash = this._genHash();\n        }\n    }\n    _genHash(){\n        return Sha256.hash(this.index+this.timeStamp+this.prevHash+this.root+this.nonce);\n    }\n    toString(){\n        return `\n        bloque: ${this.index}\\\\n\n        hash: ${this.hash}\\\\n\n        nonce: ${this.nonce}\\\\n\n        prev: ${this.prevHash}\\\\n\n        rootMerkle: ${this.rootMerkle}\\\\n\n        transacciones:\\\\n\n        ${this.data}\n        timeStamp: ${this.timeStamp}\n        `;\n    }\n}\n\nexport default class BlockChain{\n    constructor(){\n        this.blocks = new LinkedList();\n        this.index = 0;\n    }\n    genNewBlock(timeStamp, root, list){\n        const data = {\n            index: this.index++,\n            timeStamp: timeStamp,\n            prevHash: (this.blocks.isEmpty()) ? this.blocks.end.data.hash : '',\n            rootMerkle: root,\n            data: list,\n        };\n        this.blocks.add(new _Block(data));\n    }\n}\n\n//SHA256 CODE BECAUSE I COULDN'T EXPORT IT FROM ANOTHER FILE\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  SHA-256 implementation in JavaScript | (c) Chris Veness 2002-2010 | www.movable-type.co.uk    */\n/*   - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                             */\n/*         http://csrc.nist.gov/groups/ST/toolkit/examples.html                                   */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Sha256 = {};  // Sha256 namespace\n\n/**\n * Generates SHA-256 hash of string\n *\n * @param {String} msg                String to be hashed\n * @param {Boolean} [utf8encode=true] Encode msg as UTF-8 before generating hash\n * @returns {String}                  Hash of msg as hex character string\n */\nSha256.hash = function (msg, utf8encode) {\n    utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode;\n\n    // convert string to UTF-8, as SHA only deals with byte-streams\n    if (utf8encode) msg = Utf8.encode(msg);\n\n    // constants [§4.2.2]\n    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n    // initial hash value [§5.3.1]\n    var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n    // PREPROCESSING \n\n    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]\n\n    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]\n    var l = msg.length / 4 + 2;  // length (in 32-bit integers) of msg + ‘1’ + appended length\n    var N = Math.ceil(l / 16);   // number of 16-integer-blocks required to hold 'l' ints\n    var M = new Array(N);\n\n    for (var i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (var j = 0; j < 16; j++) {  // encode 4 chars per integer, big-endian encoding\n            M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14])\n    M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff;\n\n\n    // HASH COMPUTATION [§6.1.2]\n\n    var W = new Array(64); var a, b, c, d, e, f, g, h;\n    for (var i = 0; i < N; i++) {\n\n        // 1 - prepare message schedule 'W'\n        for (var t = 0; t < 16; t++) W[t] = M[i][t];\n        for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff;\n\n        // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value\n        a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7];\n\n        // 3 - main loop (note 'addition modulo 2^32')\n        for (var t = 0; t < 64; t++) {\n            var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];\n            var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) & 0xffffffff;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) & 0xffffffff;\n        }\n        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')\n        H[0] = (H[0] + a) & 0xffffffff;\n        H[1] = (H[1] + b) & 0xffffffff;\n        H[2] = (H[2] + c) & 0xffffffff;\n        H[3] = (H[3] + d) & 0xffffffff;\n        H[4] = (H[4] + e) & 0xffffffff;\n        H[5] = (H[5] + f) & 0xffffffff;\n        H[6] = (H[6] + g) & 0xffffffff;\n        H[7] = (H[7] + h) & 0xffffffff;\n    }\n\n    return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) +\n        Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);\n}\n\nSha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); }\nSha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); }\nSha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); }\nSha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); }\nSha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); }\nSha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); }\nSha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); }\n\n//\n// hexadecimal representation of a number \n//   (note toString(16) is implementation-dependant, and  \n//   in IE returns signed numbers when used on full words)\n//\nSha256.toHexStr = function (n) {\n    var s = \"\", v;\n    for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); }\n    return s;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */\n/*              single-byte character encoding (c) Chris Veness 2002-2010                         */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\nvar Utf8 = {};  // Utf8 namespace\n\n/**\n * Encode multi-byte Unicode string into utf-8 multiple single-byte characters \n * (BMP / basic multilingual plane only)\n *\n * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars\n *\n * @param {String} strUni Unicode string to be encoded as UTF-8\n * @returns {String} encoded string\n */\nUtf8.encode = function (strUni) {\n    // use regular expressions & String.replace callback function for better efficiency \n    // than procedural approaches\n    var strUtf = strUni.replace(\n        /[\\u0080-\\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);\n        }\n    );\n    strUtf = strUtf.replace(\n        /[\\u0800-\\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz\n        function (c) {\n            var cc = c.charCodeAt(0);\n            return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);\n        }\n    );\n    return strUtf;\n}\n\n/**\n * Decode utf-8 encoded string back into multi-byte Unicode characters\n *\n * @param {String} strUtf UTF-8 string to be decoded back to Unicode\n * @returns {String} decoded string\n */\nUtf8.decode = function (strUtf) {\n    // note: decode 3-byte chars first as decoded 2-byte strings could appear to be 3-byte char!\n    var strUni = strUtf.replace(\n        /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g,  // 3-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);\n            return String.fromCharCode(cc);\n        }\n    );\n    strUni = strUni.replace(\n        /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g,                 // 2-byte chars\n        function (c) {  // (note parentheses for precence)\n            var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;\n            return String.fromCharCode(cc);\n        }\n    );\n    return strUni;\n}"
                    }
                ],
                "ml_fragments": [
                    {
                        "type": "ml_block",
                        "block1": {
                            "start_line": 0,
                            "end_line": 50,
                            "code": "var Sha256 = {}; Sha256.hash = function (msg, utf8encode) { utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode; if (utf8encode) msg = Utf8.encode(msg); var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]; var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]; msg += String.fromCharCode(0x80); var l = msg.length / 4 + 2; var N = Math.ceil(l / 16); var M = new Array(N); for (var i = 0; i < N; i++) { M[i] = new Array(16); for (var j = 0; j < 16; j++) { M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) | (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3)); } } M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14]) M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff; var W = new Array(64); var a, b, c, d, e, f, g, h; for (var i = 0; i < N; i++) { for (var t = 0; t < 16; t++) W[t] = M[i][t]; for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff; a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7]; for (var t = 0; t < 64; t++) { var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t]; var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c); h = g; g = f; f = e; e = (d + T1) & 0xffffffff; d = c; c = b; b = a; a = (T1 + T2) & 0xffffffff; } H[0] = (H[0] + a) & 0xffffffff; H[1] = (H[1] + b) & 0xffffffff; H[2] = (H[2] + c) & 0xffffffff; H[3] = (H[3] + d) & 0xffffffff; H[4] = (H[4] + e) & 0xffffffff; H[5] = (H[5] + f) & 0xffffffff; H[6] = (H[6] + g) & 0xffffffff; H[7] = (H[7] + h) & 0xffffffff; } return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) + Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]); } Sha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); } Sha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); } Sha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); } Sha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); } Sha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); } Sha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); } Sha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); } Sha256.toHexStr = function (n) { var s = \"\", v; for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); } return s; } var Utf8 = {}; Utf8.encode = function (strUni) { var strUtf = strUni.replace( /[\\u0080-\\u07ff]/g, function (c) { var cc = c.charCodeAt(0); return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f); } ); strUtf = strUtf.replace( /[\\u0800-\\uffff]/g, function (c) { var cc = c.charCodeAt(0); return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f); } ); return strUtf; } Utf8.decode = function (strUtf) { var strUni = strUtf.replace( /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g, function (c) { var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f); return String.fromCharCode(cc); } ); strUni = strUni.replace( /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g, function (c) { var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f; return String.fromCharCode(cc); } ); return strUni; } class NodoListaTemporal { constructor(datTemporal) { this.datTemporal = datTemporal this.siguiente = null this.anterior = null } } var contadorglobal = 0 var salida = \"\" class ListaTemporal { constructor() { this.cabeza = null this.cola = null this.size = 0 } insertLista(dato) { let nodo = new NodoListaTemporal(dato); if (this.cabeza == null) { this.cabeza = nodo; this.cola = nodo; this.size++; } else if (this.cabeza != null) { let aux = this.cabeza; while (aux != this.cola) { aux = aux.siguiente; } aux.siguiente = nodo; nodo.anterior = aux this.cola = nodo; this.size++; } } eliminarLista(dato) { let nodo = this.cabeza if (this.cabeza.datTemporal == dato && this.cabeza == this.cola) { this.cabeza = null this.cola = null this.size = 0 return } while (nodo.datTemporal != dato && nodo != this.cola) { nodo = nodo.siguiente } if (nodo.datTemporal == dato && nodo.anterior == null && nodo.siguiente != null) { let tmp = nodo.siguiente this.cabeza = tmp tmp.anterior = null nodo.siguiente = null this.size-- return } else if (nodo.datTemporal == dato && nodo.siguiente != null && nodo.anterior != null) { let tmp = nodo.siguiente tmp.anterior = nodo.anterior nodo.anterior.siguiente = tmp nodo.siguiente = null nodo.anterior = null this.size-- return } else if (nodo.datTemporal == dato && nodo.siguiente == null && nodo.anterior != null) { let tmp = nodo.anterior this.cola = tmp tmp.siguiente = null nodo.anterior = null this.size-- return } if (nodo == null) { console.log(\"No se encontro el dato a eliminar\") return } } } var recarga = [] class Nodo { constructor(dato, izquierda, derecha, nodohijo) { this.dato = dato this.hash = null this.id = 0 this.nodohijo = nodohijo this.izquierda = izquierda this.derecha = derecha } } class MerkleTree { constructor() { this.raiz = null } insertar(dato) { let nodo = new Nodo(dato, null, null, true) if (this.raiz == null) { let listatmp = new ListaTemporal() listatmp.insertLista(nodo) listatmp.insertLista(new Nodo(-1, null, null, true)) this.construirArbol(listatmp) } else { let listatmp = this.ObtenerLista() listatmp.insertLista(nodo) this.construirArbol(listatmp) } this.hashing() contadorglobal = 0 } ObtenerLista() { let listatmp = new ListaTemporal() this.obtenerlista(listatmp, this.raiz.izquierda) this.obtenerlista(listatmp, this.raiz.derecha) return listatmp } obtenerlista(lista, nodo) { if (nodo != null) { this.obtenerlista(lista, nodo.izquierda) if (nodo != null && nodo.dato != -1 && nodo.nodohijo == true) { lista.insertLista(nodo) } this.obtenerlista(lista, nodo.derecha) } } construirArbol(lista) { let tamanio = new Float64Array(lista.size) let cant = 1 let operacion = tamanio.length / 2 while (operacion > 1) { cant++ operacion = operacion / 2 } let vectorTotal = new Float64Array(cant) let totalnodos = Math.pow(2, vectorTotal.length) while (lista.size < Math.floor(totalnodos)) { lista.insertLista(new Nodo(-1, null, null, true)) } while (lista.size > 1) { let primero = lista.cabeza let segundo = primero.siguiente lista.eliminarLista(primero.datTemporal) lista.eliminarLista(segundo.datTemporal) let nodo1 = primero.datTemporal nodo1.id = contadorglobal + 1 let nodo2 = segundo.datTemporal nodo2.id = contadorglobal + 2 let suma = nodo1.dato + nodo2.dato let nuevo = new Nodo(suma, nodo1, nodo2, false) nuevo.id = contadorglobal lista.insertLista(nuevo) contadorglobal = contadorglobal + 3 } this.raiz = lista.cabeza.datTemporal } hashing() { if (this.raiz == null) { console.log(\"No existe arbol\") return } this.subHashing(this.raiz) } subHashing(nodo) { if (nodo != null) { let hasheo = Sha256.hash(String(nodo.dato)) nodo.hash = hasheo this.subHashing(nodo.izquierda) this.subHashing(nodo.derecha) } } imprimiendo() { if (this.raiz == null) { console.log(\"No existe arbol\") return } this.imprimir(this.raiz) } imprimir(nodo) { if (nodo != null) { console.log(nodo.dato + \" Es el dato\") console.log(nodo.hash + \" Es el Hash\") this.imprimir(nodo.izquierda) this.imprimir(nodo.derecha) } } preOrden(nodo, vector) { if (nodo != null) { vector.push(nodo.dato) this.preOrden(nodo.izquierda, vector) this.preOrden(nodo.derecha, vector) } return vector } graficar(valorBuscar) { salida = \"\" if (this.raiz == null) { console.log(\"No hay nada aun\") return } let nodo = this.raiz let contador = 0 salida += \"digraph G{\\nnode[shape=record]\\nedge[color=\\\"green\\\"]\\n\" this.graficando(nodo, valorBuscar) salida += \"}\" contador = 0 d3.select(' .width(750) .height(400) .renderDot(salida) return console.log(salida) } graficando(nodo, valorBuscar) { if (nodo != null) { if (valorBuscar == nodo.dato) { salida += \"node\" + nodo.id + \" [color=\\\"green\\\" label = \\\" \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\" } else { salida += \"node\" + nodo.id + \" [label = \\\" \" + nodo.dato + \"|\" + nodo.hash + \" \\\"]; \\n\" } if (nodo.derecha != null) { salida += \"node\" + nodo.id + \" -> node\" + nodo.derecha.id + \"\\n\" } if (nodo.izquierda != null) { salida += \"node\" + nodo.id + \" -> node\" + nodo.izquierda.id + \"\\n\" } if (nodo.izquierda != null) { this.graficando(nodo.izquierda, valorBuscar) } if (nodo.derecha != null) { this.graficando(nodo.derecha, valorBuscar) } } } getMerkleRoot() { return this.raiz.hash } } let Transacciones = new MerkleTree() Transacciones.graficar(0)"
                        },
                        "block2": {
                            "start_line": 0,
                            "end_line": 50,
                            "code": "import LinkedList from \"../data_structs/linked_list.js\"; class _Block{ constructor({ index, timeStamp, prevHash, rootMerkle, data, }){ this.index = index; this.timeStamp = timeStamp; this.prevHash = prevHash; this.rootMerkle = rootMerkle; this.data = data; this.hash = this._genHash(); this.nonce = 0; this._proofOfWork(); } _proofOfWork(){ while(!this.hash.startsWith('00')){ this.nonce++; this.hash = this._genHash(); } } _genHash(){ return Sha256.hash(this.index+this.timeStamp+this.prevHash+this.root+this.nonce); } toString(){ return ` bloque: ${this.index}\\\\n hash: ${this.hash}\\\\n nonce: ${this.nonce}\\\\n prev: ${this.prevHash}\\\\n rootMerkle: ${this.rootMerkle}\\\\n transacciones:\\\\n ${this.data} timeStamp: ${this.timeStamp} `; } } export default class BlockChain{ constructor(){ this.blocks = new LinkedList(); this.index = 0; } genNewBlock(timeStamp, root, list){ const data = { index: this.index++, timeStamp: timeStamp, prevHash: (this.blocks.isEmpty()) ? this.blocks.end.data.hash : '', rootMerkle: root, data: list, }; this.blocks.add(new _Block(data)); } } var Sha256 = {}; Sha256.hash = function (msg, utf8encode) { utf8encode = (typeof utf8encode == 'undefined') ? true : utf8encode; if (utf8encode) msg = Utf8.encode(msg); var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]; var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]; msg += String.fromCharCode(0x80); var l = msg.length / 4 + 2; var N = Math.ceil(l / 16); var M = new Array(N); for (var i = 0; i < N; i++) { M[i] = new Array(16); for (var j = 0; j < 16; j++) { M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) | (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3)); } } M[N - 1][14] = ((msg.length - 1) * 8) / Math.pow(2, 32); M[N - 1][14] = Math.floor(M[N - 1][14]) M[N - 1][15] = ((msg.length - 1) * 8) & 0xffffffff; var W = new Array(64); var a, b, c, d, e, f, g, h; for (var i = 0; i < N; i++) { for (var t = 0; t < 16; t++) W[t] = M[i][t]; for (var t = 16; t < 64; t++) W[t] = (Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16]) & 0xffffffff; a = H[0]; b = H[1]; c = H[2]; d = H[3]; e = H[4]; f = H[5]; g = H[6]; h = H[7]; for (var t = 0; t < 64; t++) { var T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t]; var T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c); h = g; g = f; f = e; e = (d + T1) & 0xffffffff; d = c; c = b; b = a; a = (T1 + T2) & 0xffffffff; } H[0] = (H[0] + a) & 0xffffffff; H[1] = (H[1] + b) & 0xffffffff; H[2] = (H[2] + c) & 0xffffffff; H[3] = (H[3] + d) & 0xffffffff; H[4] = (H[4] + e) & 0xffffffff; H[5] = (H[5] + f) & 0xffffffff; H[6] = (H[6] + g) & 0xffffffff; H[7] = (H[7] + h) & 0xffffffff; } return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) + Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]); } Sha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); } Sha256.Sigma0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); } Sha256.Sigma1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); } Sha256.sigma0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); } Sha256.sigma1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); } Sha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); } Sha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); } Sha256.toHexStr = function (n) { var s = \"\", v; for (var i = 7; i >= 0; i--) { v = (n >>> (i * 4)) & 0xf; s += v.toString(16); } return s; } var Utf8 = {}; Utf8.encode = function (strUni) { var strUtf = strUni.replace( /[\\u0080-\\u07ff]/g, function (c) { var cc = c.charCodeAt(0); return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f); } ); strUtf = strUtf.replace( /[\\u0800-\\uffff]/g, function (c) { var cc = c.charCodeAt(0); return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f); } ); return strUtf; } Utf8.decode = function (strUtf) { var strUni = strUtf.replace( /[\\u00e0-\\u00ef][\\u0080-\\u00bf][\\u0080-\\u00bf]/g, function (c) { var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f); return String.fromCharCode(cc); } ); strUni = strUni.replace( /[\\u00c0-\\u00df][\\u0080-\\u00bf]/g, function (c) { var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f; return String.fromCharCode(cc); } ); return strUni; }"
                        },
                        "similarity": 0.7832133332332992,
                        "similarity_details": {
                            "tfidf": 0.8028736418297481,
                            "char_ngram": 0.6825066322237517,
                            "word_ngram": 0.48358712367656415,
                            "embedding": 0.9735496044158936
                        }
                    }
                ],
                "is_plagiarism": false,
                "plagiarism_probability": 0.6860685048265538,
                "all_features": {
                    "lcs": 0.5259076489249207,
                    "sequence_matcher": 0.6478506296135476,
                    "ngram": 0.7153411560191221,
                    "levenshtein": 0.4693322532114339,
                    "tfidf_cosine": 0.9678360468240756,
                    "winnowing": 0.5919003115264797,
                    "ml_tfidf": 0.8028736418297481,
                    "ml_char_ngram": 0.6825066322237517,
                    "ml_word_ngram": 0.48358712367656415,
                    "ml_embedding": 0.9735496044158936
                }
            }
        ],
        "clustering": {
            "clusters": {
                "0": [
                    {
                        "index": 0,
                        "metadata": {
                            "submission": "extracted_-EDD_junio-Proyecto2_201800992-main",
                            "path": "-EDD_junio-Proyecto2_201800992-main\\js\\Arboles\\arbolAvl.js"
                        }
                    },
                    {
                        "index": 1,
                        "metadata": {
                            "submission": "extracted_-EDD_junio-Proyecto2_201800992-main",
                            "path": "-EDD_junio-Proyecto2_201800992-main\\js\\Arboles\\arbolMerkle.js"
                        }
                    },
                    {
                        "index": 2,
                        "metadata": {
                            "submission": "extracted_-EDD_junio-Proyecto2_201800992-main",
                            "path": "-EDD_junio-Proyecto2_201800992-main\\js\\Arboles\\bts.js"
                        }
                    },
                    {
                        "index": 3,
                        "metadata": {
                            "submission": "extracted_-EDD_junio-Proyecto2_201800992-main",
                            "path": "-EDD_junio-Proyecto2_201800992-main\\js\\BlockChain\\blockChain.js"
                        }
                    },
                    {
                        "index": 4,
                        "metadata": {
                            "submission": "extracted_-EDD_junio-Proyecto2_201800992-main",
                            "path": "-EDD_junio-Proyecto2_201800992-main\\js\\Hash\\tablaHash.js"
                        }
                    },
                    {
                        "index": 5,
                        "metadata": {
                            "submission": "extracted_-EDD_junio-Proyecto2_201800992-main",
                            "path": "-EDD_junio-Proyecto2_201800992-main\\js\\Lineales\\ListaSimple.js"
                        }
                    },
                    {
                        "index": 6,
                        "metadata": {
                            "submission": "extracted_-EDD_junio-Proyecto2_201800992-main",
                            "path": "-EDD_junio-Proyecto2_201800992-main\\js\\Lineales\\transacciones.js"
                        }
                    },
                    {
                        "index": 7,
                        "metadata": {
                            "submission": "extracted_-EDD_junio-Proyecto2_201801178-main",
                            "path": "-EDD_junio-Proyecto2_201801178-main\\src\\main.js"
                        }
                    },
                    {
                        "index": 8,
                        "metadata": {
                            "submission": "extracted_-EDD_junio-Proyecto2_201801178-main",
                            "path": "-EDD_junio-Proyecto2_201801178-main\\src\\classes\\actor.js"
                        }
                    },
                    {
                        "index": 9,
                        "metadata": {
                            "submission": "extracted_-EDD_junio-Proyecto2_201801178-main",
                            "path": "-EDD_junio-Proyecto2_201801178-main\\src\\classes\\category.js"
                        }
                    },
                    {
                        "index": 10,
                        "metadata": {
                            "submission": "extracted_-EDD_junio-Proyecto2_201801178-main",
                            "path": "-EDD_junio-Proyecto2_201801178-main\\src\\classes\\comment.js"
                        }
                    },
                    {
                        "index": 11,
                        "metadata": {
                            "submission": "extracted_-EDD_junio-Proyecto2_201801178-main",
                            "path": "-EDD_junio-Proyecto2_201801178-main\\src\\classes\\graph.js"
                        }
                    },
                    {
                        "index": 12,
                        "metadata": {
                            "submission": "extracted_-EDD_junio-Proyecto2_201801178-main",
                            "path": "-EDD_junio-Proyecto2_201801178-main\\src\\classes\\movie.js"
                        }
                    },
                    {
                        "index": 13,
                        "metadata": {
                            "submission": "extracted_-EDD_junio-Proyecto2_201801178-main",
                            "path": "-EDD_junio-Proyecto2_201801178-main\\src\\classes\\rent.js"
                        }
                    },
                    {
                        "index": 14,
                        "metadata": {
                            "submission": "extracted_-EDD_junio-Proyecto2_201801178-main",
                            "path": "-EDD_junio-Proyecto2_201801178-main\\src\\classes\\ui.js"
                        }
                    },
                    {
                        "index": 15,
                        "metadata": {
                            "submission": "extracted_-EDD_junio-Proyecto2_201801178-main",
                            "path": "-EDD_junio-Proyecto2_201801178-main\\src\\classes\\user.js"
                        }
                    },
                    {
                        "index": 16,
                        "metadata": {
                            "submission": "extracted_-EDD_junio-Proyecto2_201801178-main",
                            "path": "-EDD_junio-Proyecto2_201801178-main\\src\\data_structs\\avl_tree.js"
                        }
                    },
                    {
                        "index": 17,
                        "metadata": {
                            "submission": "extracted_-EDD_junio-Proyecto2_201801178-main",
                            "path": "-EDD_junio-Proyecto2_201801178-main\\src\\data_structs\\block.js"
                        }
                    },
                    {
                        "index": 18,
                        "metadata": {
                            "submission": "extracted_-EDD_junio-Proyecto2_201801178-main",
                            "path": "-EDD_junio-Proyecto2_201801178-main\\src\\data_structs\\bst.js"
                        }
                    },
                    {
                        "index": 19,
                        "metadata": {
                            "submission": "extracted_-EDD_junio-Proyecto2_201801178-main",
                            "path": "-EDD_junio-Proyecto2_201801178-main\\src\\data_structs\\hash_map.js"
                        }
                    },
                    {
                        "index": 20,
                        "metadata": {
                            "submission": "extracted_-EDD_junio-Proyecto2_201801178-main",
                            "path": "-EDD_junio-Proyecto2_201801178-main\\src\\data_structs\\linked_list.js"
                        }
                    },
                    {
                        "index": 21,
                        "metadata": {
                            "submission": "extracted_-EDD_junio-Proyecto2_201801178-main",
                            "path": "-EDD_junio-Proyecto2_201801178-main\\src\\data_structs\\merkle.js"
                        }
                    },
                    {
                        "index": 22,
                        "metadata": {
                            "submission": "extracted_EDD_junio-Proyecto2_201801518-master",
                            "path": "EDD_junio-Proyecto2_201801518-master\\index.js"
                        }
                    }
                ]
            },
            "noise": [],
            "intra_cluster_similarities": {
                "0": 0.9777370095252991
            },
            "visualization": "iVBORw0KGgoAAAANSUhEUgAAC7gAAAlgCAYAAAAY53oSAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjMsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvZiW1igAAAAlwSFlzAAAuIwAALiMBeKU/dgABAABJREFUeJzs3Qd4ZGX5N+An2cJ2dpels8Cy9CJVpAoKolIEpSkgIBaanyIq2AELiAX8KwqCIAiKIr2pgPTeBKS3pfftvWW/6znZxEyS3U2yyeYkue/rmitzzsx533fOnDkzsL/3OVXz5s2bFwAAAAAAAAAAAAAA0MmqO3sAAAAAAAAAAAAAAACQBNwBAAAAAAAAAAAAACgFAXcAAAAAAAAAAAAAAEpBwB0AAAAAAAAAAAAAgFIQcAcAAAAAAAAAAAAAoBQE3AEAAAAAAAAAAAAAKAUBdwAAAAAAAAAAAAAASkHAHQAAAAAAAAAAAACAUhBwBwAAAAAAAAAAAACgFATcAQAAAAAAAAAAAAAoBQF3AAAAAAAAAAAAAABKQcAdAAAAAAAAAAAAAIBSEHAHAAAAAAAAAAAAAKAUBNwBAAAAAAAAAAAAACgFAXcAAAAAAAAAAAAAAEpBwB0AAAAAAAAAAAAAgFIQcAcAAAAAAAAAAAAAoBQE3AEAAAAAAAAAAAAAKAUBdwAAAAAAAAAAAAAASkHAHQAAAAAAAAAAAACAUhBwBwAAAAAAAAAAAACgFATcAQAAAAAAAAAAAAAoBQF3AAAAAAAAAAAAAABKQcAdAAAAAAAAAAAAAIBSEHAHAAAAAAAAAAAAAKAUBNwBAAAAAAAAAAAAACgFAXcAAAAAAAAAAAAAAEpBwB0AAAAAAAAAAAAAgFIQcAcAAAAAAAAAAAAAoBQE3AEAAAAAAAAAAAAAKAUBdwAAAAAAAAAAAAAASkHAHQAAAAAAAAAAAACAUhBwBwAAAAAAAAAAAACgFATcAQAAAAAAAAAAAAAoBQF3AAAAAAAAAAAAAABKQcAdAAAAAAAAAAAAAIBSEHAHAAAAAAAAAAAAAKAUBNwBAAAAAAAAAAAAACgFAXcAAAAAAAAAAAAAAEpBwB0AAAAAAAAAAAAAgFIQcAcAAAAAAAAAAAAAoBQE3AEAAAAAAAAAAAAAKAUBdwAAAAAAAAAAAAAASkHAHQAAAAAAAAAAAACAUhBwBwAAAAAAAAAAAACgFATcAQAAAAAAAAAAAAAoBQF3AAAAAAAAAAAAAABKQcAdAAAAAAAAAAAAAIBSEHAHAAAAAAAAAAAAAKAUBNwBAAAAAAAAAAAAACgFAXcAAAAAAAAAAAAAAEpBwB0AAAAAAAAAAAAAgFIQcAcAAAAAAAAAAAAAoBQE3AEAAAAAAAAAAAAAKAUBdwAAAAAAAAAAAAAASkHAHQAAAAAAAAAAAACAUhBwBwAAAAAAAAAAAACgFATcAQAAAAAAAAAAAAAoBQF3AAAAAAAAAAAAAABKQcAdAAAAAAAAAAAAAIBSEHAHAAAAAAAAAAAAAKAUBNwBAAAAAAAAAAAAACgFAXcAAAAAAAAAAAAAAEpBwB0AAAAAAAAAAAAAgFIQcAcAAAAAAAAAAAAAoBQE3AEAAAAAAAAAAAAAKAUBdwAAAAAAAAAAAAAASkHAHQAAAAAAAAAAAACAUhBwBwAAAAAAAAAAAACgFATcAQAAAAAAAAAAAAAoBQF3AAAAAAAAAAAAAABKQcAdAAAAAAAAAAAAAIBSEHAHAAAAAAAAAAAAAKAUBNwBAAAAAAAAAAAAACgFAXcAAAAAAAAAAAAAAEpBwB0AAAAAAAAAAAAAgFIQcAcAAAAAAAAAAAAAoBQE3AEAAAAAAAAAAAAAKAUBdwAAAAAAAAAAAAAASkHAHQAAAAAAAAAAAACAUhBwBwAAAAAAAAAAAACgFATcAQAAAAAAAAAAAAAoBQF3AAAAAAAAAAAAAABKQcAdAAAAAAAAAAAAAIBSEHAHAAAAAAAAAAAAAKAUBNwBAAAAAAAAAAAAACgFAXcAAAAAAAAAAAAAAEpBwB0AAAAAAAAAAAAAgFIQcAcAAAAAAAAAAAAAoBQE3AEAAAAAAAAAAAAAKAUBdwAAAAAAAAAAAAAASkHAHQAAAAAAAAAAAACAUhBwBwAAAAAAAAAAAACgFATcAQAAAAAAAAAAAAAoBQF3AAAAAAAAAAAAAABKQcAdAAAAAAAAAAAAAIBSEHAHAAAAAAAAAAAAAKAUBNwBAAAAAAAAAAAAACgFAXcAAAAAAAAAAAAAAEpBwB0AAAAAAAAAAAAAgFIQcAcAAAAAAAAAAAAAoBQE3AEAAAAAAAAAAAAAKAUBdwAAAAAAAAAAAAAASkHAHQAAAAAAAAAAAACAUhBwBwAAAAAAAAAAAACgFATcAQAAAAAAAAAAAAAoBQF3AAAAAAAAAAAAAABKQcAdAAAAAAAAAAAAAIBSEHAHAAAAAAAAAAAAAKAUBNwBAAAAAAAAAAAAACgFAXcAAAAAAAAAAAAAAEpBwB0AAAAAAAAAAAAAgFIQcAcAAAAAAAAAAAAAoBQE3AEAAAAAAAAAAAAAKAUBdwAAAAAAAAAAAAAASkHAHQAAAAAAAAAAAACAUhBwBwAAAAAAAAAAAACgFATcAQAAAAAAAAAAAAAoBQF3AAAAAAAAAAAAAABKQcAdAAAAAAAAAAAAAIBSEHAHAAAAAAAAAAAAAKAUBNwBAAAAAAAAAAAAACgFAXcAAAAAAAAAAAAAAEpBwB0AAAAAAAAAAAAAgFIQcAcAAAAAAAAAAAAAoBQE3AEAAAAAAAAAAAAAKAUBdwAAAAAAAAAAAAAASkHAHQAAAAAAAAAAAACAUhBwBwAAAAAAAAAAAACgFATcAQAAAAAAAAAAAAAoBQF3AAAAAAAAAAAAAABKQcAdAAAAAAAAAAAAAIBSEHAHAAAAAAAAAAAAAKAUBNwBAAAAAAAAAAAAACgFAXcAAAAAAAAAAAAAAEpBwB0AAAAAAAAAAAAAgFIQcAcAAAAAAAAAAAAAoBQE3AEAAAAAAAAAAAAAKAUBdwAAAAAAAAAAAAAASkHAHQAAAAAAAAAAAACAUhBwBwAAAAAAAAAAAACgFATcAQAAAAAAAAAAAAAoBQF3AAAAAAAAAAAAAABKQcAdAAAAAAAAAAAAAIBSEHAHAAAAAAAAAAAAAKAUBNwBAAAAAAAAAAAAACgFAXcAAAAAAAAAAAAAAEpBwB0AAAAAAAAAAAAAgFIQcAcAAAAAAAAAAAAAoBQE3AEAAAAAAAAAAAAAKAUBdwAAAAAAAAAAAAAASkHAHQAAAAAAAAAAAACAUhBwBwAAAAAAAAAAAACgFATcAQAAAAAAAAAAAAAoBQF3AAAAAAAAAAAAAABKQcAdAAAAAAAAAAAAAIBSEHAHAAAAAAAAAAAAAKAUBNwBAAAAAAAAAAAAACgFAXcAAAAAAAAAAAAAAEpBwB0AAAAAAAAAAAAAgFIQcAcAAAAAAAAAAAAAoBQE3AEAAAAAAAAAAAAAKAUBdwAAAAAAAAAAAAAASkHAHQAAAAAAAAAAAACAUhBwBwAAAAAAAAAAAACgFATcAQAAAAAAAAAAAAAoBQF3AAAAAAAAAAAAAABKQcAdAAAAAAAAAAAAAIBSEHAHAAAAAAAAAAAAAKAUBNwBAAAAAAAAAAAAACgFAXcAAAAAAAAAAAAAAEpBwB0AAAAAAAAAAAAAgFIQcAcAAAAAAAAAAAAAoBQE3AEAAAAAAAAAAAAAKAUBdwAAAAAAAAAAAAAASkHAHQAAAAAAAAAAAACAUhBwBwAAAAAAAAAAAACgFATcAQAAAAAAAAAAAAAoBQF3AAAAAAAAAAAAAABKQcAdAAAAAAAAAAAAAIBSEHAHAAAAAAAAAAAAAKAUBNwBAAAAAAAAAAAAACgFAXcAAAAAAAAAAAAAAEpBwB0AAAAAAAAAAAAAgFIQcAcAAAAAAAAAAAAAoBQE3AEAAAAAAAAAAAAAKAUBdwAAAAAAAAAAAAAASkHAHQAAAAAAAAAAAACAUhBwBwAAAAAAAAAAAACgFATcAQAAAAAAAAAAAAAoBQF3AAAAAAAAAAAAAABKQcAdAAAAAAAAAAAAAIBSEHAHAAAAAAAAAAAAAKAUBNwBAAAAAAAAAAAAACgFAXcAAAAAAAAAAAAAAEpBwB0AAAAAAAAAAAAAgFIQcAcAAAAAAAAAAAAAoBQE3AEAAAAAAAAAAAAAKAUBdwAAAAAAAAAAAAAASkHAHQAAAAAAAAAAAACAUhBwBwAAAAAAAAAAAACgFATcAQAAAAAAAAAAAAAoBQF3AAAAAAAAAAAAAABKQcAdAAAAAAAAAAAAAIBSEHAHAAAAAAAAAAAAAKAUBNwBAAAAAAAAAAAAACgFAXcAAAAAAAAAAAAAAEpBwB0AAAAAAAAAAAAAgFIQcAcAAAAAAAAAAAAAoBQE3AEAAAAAAAAAAAAAKAUBdwAAAAAAAAAAAAAASkHAHQAAAAAAAAAAAACAUhBwBwAAAAAAAAAAAACgFATcAQAAAAAAAAAAAAAoBQF3AAAAAAAAAAAAAABKQcAdAAAAAAAAAAAAAIBSEHAHAAAAAAAAAAAAAKAUBNwBAAAAAAAAAAAAACgFAXcAAAAAAAAAAAAAAEpBwB0AAAAAAAAAAAAAgFIQcAcAAAAAAAAAAAAAoBQE3AEAAAAAAAAAAAAAKAUBdwAAAAAAAAAAAAAASkHAHQAAAAAAOsicOXNiu+22i6qqqvrbSiutFC+//HJnDw0AAAAAAEpJwB0AAAAAADrIt771rbjrrrvqlwcPHhzXX399rLbaap06LgAAAAAAKCsBdwAAAAAoqZdeeqmi6nPezj///M4eFhGx4447VrwvudyR29G+8nPU+LOVn7f2dtVVV8Uvf/nL+uU+ffrEZZddFptsskm799UT3HrrrU3et1zHktF435944omdPSQAAAAAoJvq3dkDAAAAAACA7mbMmDFx6KGHVqw799xz4yMf+UinjYnu7d13340nn3yymKwxduzYmD59evTt2zeGDh0aw4YNi9VXXz3e9773FesAAAAAAMpMwB0AAAAAIuJ3v/tdHH300RXrdtppp7jppps6pL/jjz8+fvazn1Ws++IXvxhnn312h/QHLDkzZ86MfffdNyZMmFC/7uSTT47PfvaznTouup877rgjLrnkkrj++uvjxRdfXOTzM9y+8cYbxy677FIcj+uss84SGScAAAAAQGtUt+rZAAAAANBNHXDAAdGvX7+KdTfffHO8/PLL7d7X3Llz48ILL2yy/vOf/3y79wUsecccc0w89NBD9ctHHnlkfPvb3+7UMdG9XH311bHpppvGBz/4wTjjjDNaFG5Ps2bNigceeCB+8pOfxLrrrhtbbrllXHHFFR0+3u7u/PPPj6qqqopbVtIHAAAAANpGwB0AAAAAImLo0KGx9957V6ybN29eEVprb//4xz/izTffrFi3wQYbxAc+8IF27wtYsi6++OI466yz6pf33HPP+M1vftOpY6L7eOedd2L33XcvjqtHHnlksdvLsPunPvWp2HbbbePRRx9tlzECAAAAACyu3ovdAgAAAAB0E1lB/c9//nPFugy4/+AHPyiqsbaX8847r9m+ga7t6aefji996Uv1y1tttVUReO/Vq1enjovuIQPtu+66a5MJUnXyOMuJUttss00sv/zyseyyy8bAgQNjypQp8eqrr8ZTTz0Vt99+e7z++utNtr377ruLSu4bb7zxEnglAAAAAAALJ+AOAAAAAPPtuOOOscYaa8SLL75Yv+6ll16KW265JT784Q+3Sx/vvvtuXHvttRXr+vTpEwcddFCT566++upFFXm6j1tvvbWzh0BEHHroocWtPU2bNi322WefIkyc1l577bjmmmuif//+7doPPdODDz4YO++8c0ycOLHJYyNHjiwmYu27776x9NJLL7Kt+++/P/74xz8WE7hmzJjRQSMGAAAAAGi76sXYFgAAAAC6lazSfthhh7Wo4npbXXTRRTF79uyKdZ/4xCeKSrtA1zVgwIB4/PHHi0kpeXvmmWdixIgRnT0suoGsvr7HHns0Cbfnd1YG25999tn4whe+0KJwe9pyyy3jzDPPjDFjxhQTPdrzCiUAAAAAAO1BwB0AAAAAGsiwX69evSrWXX755TFp0qR2aT+r5jb2+c9/vl3aBqB7yckShxxySLz11ltNrvxxwQUXxEknnRT9+vVrU9srrLBC8Z10/fXXx3LLLddOIwYAAAAAWHwC7gAAAADQwMorrxwf/ehHK9ZNnz49Lr744sVu+4EHHoj//ve/FetWWWWVJv0BQMoA+i233NJk/a9//ev47Gc/2y59fOxjHyu+nzbYYIN2aQ8AAAAAYHH1XuwWAAAAAKCbyYrqWdG2ccjw8MMPb/fq7VmZt7q64+tQjBs3Lh577LF44YUXimr0U6dOjb59+8aAAQOKyr2rr756rL322jF06NDoyubOnRsvvvhiPP300/H6668XrzXXDRs2rLitu+66sdFGGy2Rfd5dzJo1K55//vlin2YV6bqrGQwfPry45f5cZ511OryK9RNPPBHPPfdcjB07Nt57772oqqqKIUOGxMiRI2O99daLNdZYo1jXWaZNmxb33XdfvPHGG/Huu+/GjBkzYtllly0+X5tuumkxmWVJyH300EMPFcf/zJkzY5lllomVVloptttuu+IzUCb5vuZYc8y532bPnl0cU/k53XLLLdtcmby1XnnlleL8mO9b3vIqHiNGjCj229Zbbx2DBg2KzpDv3wknnNBk/a677hpHHHFEu/a16qqrFree4NVXX41HH320/jsi93P//v1j4MCBxXte9324pI6/rnrM5uc29+Nrr70WU6ZMKX5T5FUBDj744EVu21N+kwAAAADQdgLuAAAAANDIHnvsUQRTMzRWJ4OrTz75ZKy//vptajPDro2rwGcY97DDDlvgNi+99FKMGjWqSUj+0EMPbXGf55xzTlx44YVFdd5FyfFkUPmDH/xg7LPPPvGhD30oevde8P9CPPHEE+Okk05qElhtrcV9nc8++2xcfvnlRZXju+66qwjKLczSSy8dH/nIR+Ib3/hGfOADH4glaccdd4zbbrutfnmHHXaIW2+9tcXPbw85qeL8889f6HMeeeSRuPLKK4t9msd+BkAXJj8vu+++e3zzm98swubt5fbbb48zzzwzbr755njnnXcW+tzll18+dt555zjggAOKitQLm8SQr/9zn/tcxboxY8YUocrW+vvf/158znKsC9tPWR07P1fHHntsEcxvrcbh/Qw+52cw1dTUxAUXXBCnnXZaPP74481unwHYPJ5+/OMfx1ZbbRWdKT+jp5xySnFuyqBuczJs/OlPfzq++93vNjk/tIcMN59++ulx3XXXFZM3FqRPnz7F/jr66KNjv/32W6KTKC699NIiPNxQHte//e1vo6soy/dETqA444wziu/hbGtRMmy9ySabFOeUfffdt7jfWPadn7sFaclx2/BzXJZjdmHnmvzs/uY3vynOeTmZrDkLCrh39G8SAAAAALoXZYoAAAAAoJlwWHMBreYqsLdUBrAnTJhQsS7Dpll1uiNkaDrD+F/5yldaFCSrCx1maO7ss8+OXXbZJW666aYos6zkvdlmmxUBuG9/+9txww03LDLcniZOnFgERzMAuNdeezV5X3qyfP9zf2bF8QylLiq0XScng+TnI0PcX/ziF1u0zcJkVeAMM+YEgL/+9a+LDLent99+O/785z/HbrvtVryvHe0///lPUWU8A6Q33njjIl9zVqDPfTp69Oj4/e9/327jyNBrVmfPyTILCrenvJLBv//976K6c4bGO0uOIc9NP/nJTxYYbk/5WT733HNjww03XGiIuLWmT59eTMRYc80145e//OVCg8Ipq8rfcccdRdg+Q84L28ftrbnvnDy+2zIRoyfLCQF5XstJFS0Jt9ddueL++++Pk08+uTgfZji7s5TlmM3JTvnZze/bBYXbe/JvEgAAAADal4A7AAAAADTj85//fJN1WXV0zpw57RZUbK6P9nD99dcXFayzInV3Nnny5CJkvDiuuuqqIqTcuEpyT/XWW28VFfHbKgOJf/jDH4qKu5MmTWpTG3/7299im222WWhl+0Vpa98t9c9//jO23377Fgc1G3rvvffiiCOOiK9+9atF5fXFkSHTvArBPffc06rtMrT7ve99L5a0a6+9NnbdddeFBtsbmzZtWlEp+6yzzmqX4zsnFv3iF79oU2D5scceK47NPMd2tJyIkxNMGjv88MM7vO/u5Pvf/358+ctfjilTpkRXVJZjNo/FHEdrPrs97TcJAAAAAO3LtfwAAAAAoBnrrbdeUem4YXA0K0RnUOsTn/hEq9rKQNjNN99csW7o0KGx9957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v/zlooJ7S2Xl+e9///tt6j/PwTk5oU5elaC596AlfvCDH1R8hvJ15SSOjjB+/Pgm69oa8u+JGn8XdqXvwzIes8cee2ysvPLKrd7ObxIAAAAA2krAHQAAAAAWYptttol11123Yt0TTzwR999//yK3nTRpUlHduaGsXHrggQdGR2kcHuvqge2OttZaa1Us33vvvdFVzZs3Lw477LAmVejzigFZATsr3pdxn+bnqXG1+e233z622mqrKJPmKp0fddRRrW5nhx12iA022KBi3X//+994++23W9VOhv8POOCAVlfZb/z+PPPMM9GR/vGPfzRZ15ZK2oceemibjuFLL720yWSPUaNGRVuMHDmySQX+W2+9NTrC9OnTm6xrzWSGnq65IHVX+T4s2zGbAfn8bmkLv0kAAAAAaKu2XWsWAAAAAHqQrLj+zW9+s0kV9y233HKh21188cVNQop77bVXDB8+PDrKBz7wgbjqqqvql//85z/H1ltvHUceeWSHV+8ug9dffz3uvvvueOyxx+LZZ5+NiRMnFhMN8n3IAHhjjStLv/LKK9FVHXfccXHRRRdVrFt99dWLgPGQIUPa3G6GzzOknvs07+f+zNvMmTOb3aeN9+Gi9mlzYcvPfvazUSZz586N++67r2JdTnxpHFRvqX333bcI9jd01113xac+9akWt5ETANoS+B49enQ8/fTT9cv5GelIjSc45H5rTfX2Onne3HHHHZtM4FiYPEYbv2/bbrttLI4MGudnoc5//vOf6AjNfbZ6wjm8veREjjxmxo0bV7/u+OOPj7XXXruYQFNWZTxm11xzzVhllVXa1HdP/00CAAAAQNsJuAMAAADAIhx88MHxne98J2bPnl2/7q9//Wucfvrp0a9fvwVulyH45sLyHelzn/tcRZgsQ5JHH310/O53vyse23PPPYuwWneTFW/zNd52221RU1PT5nYmTJgQXdGvfvWr+MUvftGkcu4///nPWHHFFVvdXu7Dc889N84555x44IEHFmtsi9qn99xzT5N1ixvobG9Z5Xzq1KkV67bYYos2t/f+97+/ybqHH364VQH3xpXYW6pxFfCODLhPmzatIkyfNt988za3l9u2JuD+0EMPxYwZMyrWnXfeeXHllVe2eQyNJ2y899570RH69+/fbc5PnaG6urr47s5zY52xY8fGBz/4wfjIRz4SBx10UOy6664xYsSIKJMyHrObbbZZm/vuqb9JAAAAAFh8Au4AAAAAsAjLLbdc7L777nHFFVdUBA0vv/zyOOCAA5rd5sknn2xShXW11VaLnXbaqUPHmmGxrBLfOAyX1aK/8Y1vFLeRI0fGdtttV4Rst9lmmyI02rt31/xfhW+88UZR7fvmm29ul/Y6upp1R/jb3/4Wxx57bMW6AQMGxLXXXhvrrLNOq9t76qmn4sADD2y3ytSL2qdvv/12xXIei22p8N2RmguELs4Y119//Rb1sTBtvRJEnz59KpYbTtxpb++++26TSuRtOSYbVn9vjddee63JuldffbW4tZcMTXeE5t5fAffW+d73vhdXX311vPjiixXrb7zxxuKWFcTzKgz5PZjfh1nZfXGOz/ZQxmM2fwO1VU/7TQIAAABA+6lux7YAAAAAoNtqrvJ6VlVdkOYey2qlWVW2o/35z39eYPA+ZVDu4osvLkLRW221VQwbNqyoHH3JJZfEzJkzo6t4/fXXY4cddmi3cHuaM2dOdCX52rNKccMQca9evYrQe763rfX4448X+7S9wu0tCVCPGzeuSYXxDJ6Wyfjx45usGzp0aJvby8/covZDa4PqZdRcILtxBfnWaO22HRU+b2j69Okd0u4qq6yyyMkgLFxexeKmm26KTTfdtNnH87yZ57yzzz47vvjFLxYTKPKKF0cccURxNZDOUMZjdsiQIYvVX0/5TQIAAABA+xJwBwAAAIAW+NjHPhYrrbRSk3Dxyy+/3GxI+qKLLqpYl8H2Qw89NJaErN6dgbJ//etfseOOOy4yLDxlypSiOv3+++8fo0ePjt///vdNqi6XUe7P559/vsn6TTbZJL797W8Xr+nhhx+Ot956KyZNmhSzZs0qXlfD2wknnBBd1SOPPBKf/OQni9fVUL5/ecWBtgTR99tvv6LqdmNZXffEE08sqsI/+uij8c4778TkyZOLY73xPj3kkENa1W++Nw0NGjQoyiZfa2MDBw5sc3vNbdtcH13dkthvrZ2Y0FU0V0n8wQcf7JSxdGWjRo0qrqZy1llntag6e35f5Dk0vzuzovgtt9wSS1IZj9nFrabeU36TAAAAANC+BNwBAAAAoAWyKnbjgHoGrs4///wmz73uuuuaVNrdaaedYrXVVoslaZdddinCeWPGjIkzzjgj9t133yYh/eaqomf12j333LNJcLpMch9nZd6GlltuuSJAl9XHTz755Nhrr72Kyr3LL798DB48uNmK1x1VfbmjvfTSS7Hrrrs2CYf/8Ic/bPZqAy2RVYyfeuqpinUZLnzggQfijjvuKCYD7LbbbvG+970vll122SKInp+L9q4OnOHGssnjp7GpU6e2ub3mtm2uj65uSey3henfv3+TdWeeeWaTSRmLc8vPYkfYfPPNm6x78sknF2v/9VR57j/88MPj6aefLiYJ/PjHPy6+HxdVmTyfm9/dP/nJT5bYWLvyMduTf5MAAAAA0P4E3AEAAACghQ477LAmlUcvuOCCJpVFzzvvvCbbtjV03B4yWH/00UfHJZdcUoTFsup8Vpj/0pe+FKusskqz21xzzTXFNktCVg5vrYsvvrhiOYPWOeYM0LXGuHHjoqt577334qMf/Wi8+eabFeszwPn973+/ze023qcZTs5JBFtssUWH7tNlllmmYnnixImlq9Y7bNiwJusmTJjQ5vaa23b48OHR3QwdOrTJunx/26q1244YMaLLfubzqgmNK2fPnTs3brvttuiJ2vI9saCJA9/97neLyVBZLf2xxx6L3/72t7HPPvs0G3jPc9H3vve9ogL5ktCVj9nu8psEAAAAgHIQcAcAAACAFspq1jvssEPFuqxEmhVJ62Tl9uuvv75JcDWriZfFqquuGgceeGD8/ve/j1dffbUYf3PB8HPPPTeeeOKJBbbTXEX0toQQx44d2+ptbrzxxorlj33sY7Hlllu2up0XX3wxupJp06bF7rvvHs8++2zF+jy+MqTZVlk1/Z577qlYd/DBB8fqq6/e4ft0hRVWqFieM2dOUam6TLJifWONq923RnOvr7lga1eX+63xpKBnnnmmze1lBe7WyKs3NJZh2q5g6aWXjg9+8INN1ud5uyvpzO+JRamuro6NNtoojjrqqPj73/8e77zzTvzlL3+Jtddeu8lzjz/++OLc1NG68jHb2b9JAAAAAOheBNwBAAAAoBWaq8T+xz/+sf7+hRde2CQEl8GtpZZaKspqxx13LKrZZvXUxpVrr7jiigVu11y120mTJrW6/+eff75Vz585c2YRRGxo++23b3W/WQ35/vvvj64ij6v99tsv7rvvvor12267bRHKzCr2bfXGG29ETU3NYu/TnODR2oD71ltv3WTdXXfdFWWSgddBgwZVrHvwwQfb3N4DDzzQbGXp7mbAgAGx7rrrVqx76KGH2txea7fNqw9kiLmh22+/PbrSVUMau+666+KVV16JrqKzvifaIr+nP/OZzxTH2aabblrxWFYav/feezt8DF39mO3M3yQAAAAAdC8C7gAAAADQCnvvvXdRWbehyy67rD6w1zDsvrBQfBmdfPLJTULSjz322AKfP3To0HapiH7bbbctdiXfrJLfWllpPyuXdxWHH354EW5taP31149rrrkm+vfvv1htv/fee+2yTy+55JI2hRkby4kiZZKfi8ZXCMhq4m2tJpzVohvbZpttojvaaqutmuy31lZiT+PHj49bb721VdvkMdx44kD2XbYrBCzIPvvsEyuvvHKTiTlHH310dBWd9T2xOHIyywknnNBk/cK+D3v37t1kXb5XrdXVj9nO/E0CAAAAQPci4A4AAAAArZBB4gMOOKBi3fTp0+Piiy8uKms3DqFlUG3jjTeOrmCZZZaJZZddtmLdxIkTF/j8ddZZp8m61lZEz/b/9re/tWqbgQMHtiigvSinnXZadBXf+9734rzzzqtYl8HXf/7znzFs2LDFbr899uns2bPjN7/5Tav7Xm+99ZocS3feeWfcc889USYf/ehHm6w766yzWt3OHXfcEY8//njFuve9732x/PLLR3f08Y9/vMm6c845p9XtXHDBBTFr1qxWb7fnnns2WffTn/40uoKsKH7SSSc1WX/ttde2aR8uTFaFv/TSS6O9ddb3xOJqfOWBunEsyODBg5usa+sEqq58zHbmbxIAAAAAuhcBdwAAAABopeYqsmfl9sYB5AU9t6xmzJhRVEluqHG4rHEot0+fPhXr/vKXv7SqzwxvTp48uVXbZAX9AQMGVKy74YYbWtXGH/7wh1ZXg+4sZ555ZvzkJz9pUhU5w+0jR45slz5WXHHFJutau0/zvXzuuefa1P/xxx/fZN2hhx4aU6dOjbI47LDDol+/fk0C7q2pKDxnzpz4f//v/zVZ39y67mKvvfZqEt4/44wz4plnnmlxG++++2788Ic/bFP/X/7yl5tUEb/oooviiiuuiK4gj7vmrnKQr6u159sF+cc//hHvf//7m0y8aA+d9T2xuN58880m6xb2fdjcRKO2VKrvDsdsZ/0mAQAAAKB7EXAHAAAAgFZqrip7Vm+/8MILF1ntvSM9//zz8aMf/agIg7bF73//+5g5c2bFuoVVn8+wb+Pg5d133x2XXXZZi/rL/fWrX/2qTWPdbrvtKpYzrH799de3aNsMhn/lK1+JruDyyy8vwo6NqzpfeeWVseGGG7ZbP8stt1ysvfbaFev+/Oc/x6OPPtqi7XOCxymnnNLm/g866KBYY401KtY9++yzsdtuu8WECRNa3d5LL70U7W3EiBFx8MEHNwms77333s2GYRubN29efOELX2iyT3Pf5+vvrjLcfNRRR1Wsy0rsud/Gjh27yO2nTZsWn/rUp5oEXVszIeab3/xmk/ci38urrroqFicUfuSRR0ZHq6qqij/96U9NJgnkPszjJs/5jc/bLZXHbU4k2XXXXeOdd96JjtBZ3xNXX311cV5q6775v//7vybrFvZ92Nz5uKXfSd3tmO2s3yQAAAAAdC8C7gAAAADQBs1VZp8+fXrFcoYyM6i2pEyZMiV+8IMfxKqrrloEH7Paa+MxNSeDkr/4xS+aBOp69eoVn/70pxe6bQZ2G8sQXgawFyQDy9nXIYccUoT2GlfFbon99tuvybr9998/Lr300gVuk/siq0Dvueee9ftlyJAhUVYPP/xwHHjggVFTU1O/rrq6uqjku8MOO7R7f4336ezZs+NjH/vYQivd53v51a9+tfg81I2zLfs0Q9B/+9vfivB+Q7fddltsscUW8fe//704VhYmq71nGx/84Afjc5/7XHSEDPGvvPLKTUKc2267bdx0000L3O71118vjrsLLrigyWNnn312mz4DXclxxx0X66yzTsW6J554opiocu+99y5wu6wonuHoO++8s37SUFv733nnnZucLz/5yU/Gl770pRZX2s4rFJx88slFmDlD4XfccUcsCXmlhmuvvbbJ90l+JvKcn5NT8goikyZNalF7Dz74YBF0zkklzR2T7a0zvifyPc3q9/l9eOyxxxbHUMNz6YK89957RZ+Nx5b7OKvcL8jw4cNj3XXXrViXAfvTTz89Jk6cGD3tmO2s3yQAAAAAdB+9O3sAAAAAANAVZfA4w1cLqw7bXAh+SZgxY0ZRfTtvGQjdZJNNYtNNN4211lorhg4dGoMHDy7G/dZbbxXVpLOieXPVe7/1rW8VwcqFyRB/VrR/6KGHKiouZwhv6623jt133z1WX331ogrx22+/XYRZs7+6wF+uP+2005pUeF6UDEdm2PiFF16oCNPtu+++sdlmm8Uee+wRa665ZhGczteW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VNdee20RbL/88subfXzYsGGx9tprx/vf//4YNWpUUbm9sUmTJsV3vvOd2H777ZfAiOlOvvKVr8TPf/7zinU5KWDkyJGx2WabxYgRIyoemzp1alHJPa8yAED7E3AHAAAAAAAAAABohbmzIt57OuLVuyNeuq32by7nelrvz3/+c+y1114xceLEivWbb755/O53v4uXXnopxo0bF88880zcf//98eKLLxYB46effjpOPfXU4nkNvfvuu0v4FdCVXXLJJcUVAxrKKwnk8ZZXFXjooYeKY+qmm24qJmHUmTt3bnHlgDw+AWhfvdu5PQAAAAAAAAAAgG5n3AsRT18Z8dbDtfdr5jR9TnXviOGjI1bYLGLdvWrvs3APPvhgHHbYYUVYuM7SSy9dBI4PPPDAoor2gqyzzjpx3HHHFbespP3tb3+7CCVDS82aNSuOP/74inVHHHFEMbGi8bG30047xe233x4777xzcdymyZMnxwknnBAXXHDBEh03QHengjsAAAAAAAAAAMACvHJnxDVfirh0/4jHL45475nacPu8uRFzZkTMmV77N5dzfT6ez8vn53a5Pc2bNGlS7L///kXIuM5yyy0Xt956axx00EELDbc39slPfjIee+yx+PznP99Bo6U7OvfccysqsK+11lpx+umnL/DYy8kXGWbv27dvxRUI8moCALQfFdwBAAAAAAAAAAAamTEh4q6fRbxww//WzZocMWNibaC9ZnbTbar7RPTuF9Fv6Yi+gyPefLj2NnqXiG2Pi+g3dIm+hNI78cQT48UXX6xfrq6ujiuvvDI22WSTNrWXoeM//OEPcfnll7fjKOnO8nhpKK8C0K9fv4Vus/766xcTMy688MJiOa8+8Mc//jFOPfXUDh0rQE8i4A4AAAAAAAAAANDAGw9G/Ps7EdPH1S5PH1t7Pyu0N1Sd6ass9Dyv9rEMvc/K2+Tax/oPj+i/TG1IPtvc6eSIlbbolJdUOhMmTIhzzjmnYt0xxxwTW2+99WK3/alPfSq6ssmTJ8d//vOfeOaZZ4r9NHPmzBgwYEAMGzYsVl999SJgvfzyy3fqGF955ZV48MEH4+23347x48cXlc1XWGGF2HbbbYu/7SkD5Pfee29Raf3NN98sljfYYIPYfffdF6vd1157LR5++OH65UGDBsV+++3Xom3zSgF1Afd01VVXCbgDtCMBdwAAAAAA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AAAAAAAAAAAAaAQBdwAAAAAAAAAAAAAAGkHAHQAAAAAAAAAAAACARhBwBwAAAAAAAAAAAACgEQTcAQAAAAAAAAAAAABoBAF3AAAAAAAAAAAAAAAaQcAdAAAAAAAAAAAAAIBGEHAHAAAAAAAAAAAAAKARBNwBAAAAAAAAAAAAAGgEAXcAAAAAAAAAAAAAABpBwB0AAAAAAAAAAAAAgEYQcAcAAAAAAAAAAAAAoBEE3AEAAAAAAAAAAAAAaAQBdwAAAAAAAAAAAAAAGkHAHQAAAAAAAAAAAACARhBwBwAAAAAAAAAAAACgEQTcAQAAAAAAAAAAAABoBAF3AAAAAAAAAAAAAAAaQcAdAAAAAAAAAAAAAIBGEHAHAAAAAAAAAAAAAKARBNwBAAAAAAAAAAAAAGgEAXcAAAAAAAAAAAAAABpBwB0AAAAAAAAAAAAAgEYQcAcAAAAAAAAAAAAAoBEE3AEAAAAAAAAAAAAAaAQBdwAAAAAAAAAAAAAAGkHAHQAAAAAAAAAAAACARhBwBwAAAAAAAAAAAACgEQTcAQAAAAAAAAAAAABoBAF3AAAAAAAAAAAAAAAaQcAdAAAAAAAAAAAAAIBGEHAHAAAAAAAAAAAAAKARBNwBAAAAAAAAAAAAAGgEAXcAAAAAAAAAAAAAABpBwB0AAAAAAAAAAAAAgEYQcAcAAAAAAAAAAAAAoBEE3AEAAAAAAAAAAAAAaAQBdwAAAAAAAAAAAAAAGkHAHQAAAAAAAAAAAACARhBwBwAAAAAAAAAAAACgEQTcAQAAAAAAAAAAAABoBAF3AAAAAAAAAAAAAAAaQcAdAAAAAAAAAAAAAIBGEHAHAAAAAAAAAAAAAKARBNwBAAAAAAAAAAAAAGgEAXcAAAAAAAAAAAAAABpBwB0AAAAAAAAAAAAAgEYQcAcAAAAAAAAAAAAAoBEE3AEAAAAAAAAAAAAAaAQBdwAAAAAAAAAAAAAAGkHAHQAAAAAAAAAAAACARhBwBwAAAAAAAAAAAACgEQTcAQAAAAAAAAAAAABoBAF3AAAAAAAAAAAAAAAaQcAdAAAAAAAAAAAAAIBGEHAHAAAAAAAAAAAAAKARBNwBAAAAAAAAAAAAAGgEAXcAAAAAAAAAAAAAABpBwB0AAAAAAAAAAAAAgEYQcAcAAAAAAAAAAAAAoBEE3AEAAAAAAAAAAAAAaAQBdwAA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AAAAAACgCgJ3AAAAAAAAAAAAAACqIHAHAAAAAAAAAAAAAKAKAncAAAAAAAAAAAAAAKogcAcAAAAAAAAAAAAAoAoCdwAAAAAAAAAAAAAAqiBwBwAAAAAAAAAAAACgCgJ3AAAAAAAAAAAAAACqIHAHAAAAAAAAAAAAAKAKAncAAAAAAAAAAAAAAKogcAcAAAAAAAAAAAAAoAoCdwAAAAAAAAAAAAAAqiBwBwAAAAAAAAAAAACgCgJ3AAAAAAAAAAAAAACqIHAHAAAAAAAAAAAAAKAKAncAAAAAAAAAAAAAAKogcAcAAAAAAAAAAAAAoAoCdwAAAAAAAAAAAAAAqiBwBwAAAAAAAAAAAACgCgJ3AAAAAAAAAAAAAACqIHAHAAAAAAAAAAAAAKAKAncAAAAAAAAAAAAAAKogcAcAAAAAAAAAAAAAoAoCdwAAAAAAAAAAAAAAqiBwBwAAAAAAAAAAAACgCgJ3AAAAAAAAAAAAAACqIHAHAAAAAAAAAAAAAKAKAncAAAAAAAAAAAAAAKogcAcAAAAAAAAAAAAAoAoCdwAAAAAAAAAAAAAAqiBwBwAAAAAAAAAAAACgCgJ3AAAAAAAAAAAAAACqIHAHAAAAAAAAAAAAAKAKAncAAAAAAAAAAAAAAKogcAcAAAAAAAAAAAAAoAoCdwAAAAAAAAAAAAAAqiBwBwAAAAAAAAAAAACgCgJ3AAAAAAAAAAAAAACqIHAHAAAAAAAAAAAAAKAKAncAAAAAAAAAAAAAAKogcAcAAAAAAAAAAAAAoAoCdwAAAAAAAAAAAAAAqiBwBwAAAAAAAAAAAACgCgJ3AAAAAAAAAAAAAACqIHAHAAAAAAAAAAAAAKAKAncAAAAAAAAAAAAAAKogcAcAAAAAAAAAAAAAoAoCdwAAAAAAAAAAAAAAqiBwBwAAAAAAAAAAAACgCgJ3AAAAAAAAAAAAAACqIHAHAAAAAAAAAAAAAKAKAncAAAAAAAAAAAAAAKogcAcAAAAAAAAAAAAAoAoCdwAAAAAAAAAAAAAAqiBwBwAAAAAAAAAAAACgCgJ3AAAAAAAAAAAAAACqIHAHAAAAAAAAAAAAAKAKAncAAAAAAAAAAAAAAKogcAcAAAAAAAAAAAAAoAoCdwAAAAAAAAAAAAAAqiBwBwAAAAAAAAAAAACgCgJ3AAAAAAAAAAAAAACqIHAHAAAAAAAAAAAAAKAKAncAAAAAAAAAAAAAAKogcAcAAAAAAAAAAAAAoAoCdwAAAAAAAAAAAAAAqiBwBwAAAAAAAAAAAACgCgJ3AAAAAAAAAAAAAACqIHAHAAAAAAAAAAAAAKAKAncAAAAAAAAAAAAAAKogcAcAAAAAAAAAAAAAoAoCdwAAAAAAAAAAAAAAqiBwBwAAAAAAAAAAAACgCgJ3AAAAAAAAAAAAAACqIHAHAAAAAAAAAAAAAKAKAncAAAAAAAAAAAAAAKogcAcAAAAAAAAAAAAAoAoCdwAAAAAAAAAAAAAAqiBwBwAAAAAAAAAAAACgCgJ3AAAAAAAAAAAAAACqIHAHAAAAAAAAAAAAAKAKAncAAAAAAAAAAAAAAKogcAcAAAAAAAAAAAAAoAoCdwAAAAAAAAAAAAAAqiBwBwAAAAAAAAAAAACgCgJ3AAAAAAAAAAAAAACqIHAHAAAAAAAAAAAAAKAKAncAAAAAAAAAAAAAAKogcAcAAAAAAAAAAAAAoAoCdwAAAAAAAAAAAAAAqiBwBwAAAAAAAAAAAACgCgJ3AAAAAAAAAAAAAACqIHAHAAAAAAAAAAAAAKAKAncAAAAAAAAAAAAAAKogcAcAAAAAAAAAAAAAoAoCdwAAAAAAAAAAAAAAqiBwBwAAAAAAAAAAAACgCgJ3AAAAAAAAAAAAAACqIHAHAAAAAAAAAAAAAKAKAncAAAAAAAAAAAAAAKogcAcAAAAAAAAAAAAAoAoCdwAAAAAAAAAAAAAAqiBwBwAAAAAAAAAAAACgCgJ3AAAAAAAAAAAAAACqIHAHAAAAAAAAAAAAAKAKAncAAAAAAAAAAAAAAKogcAcAAAAAAAAAAAAAoAoCdwAAAAAAAAAAAAAAqiBwBwAAAAAAAAAAAACgCgJ3AAAAAAAAAAAAAACqIHAHAAAAAAAAAAAAAKAKAncAAAAAAAAAAAAAAKogcAcAAAAAAAAAAAAAoAoCdwAAAAAAAAAAAAAAqiBwBwAAAAAAAAAAAACgCgJ3AAAAAAAAAAAAAACqIHAHAAAAAAAAAAAAAKAKAncAAAAAAAAAAAAAAKogcAcAAAAAAAAAAAAAoAoCdwAAAAAAAAAAAAAAqiBwBwAAAAAAAAAAAACgCgJ3AAAAAAAAAAAAAACqIHAHAAAAAAAAAAAAAKAKAncAAAAAAAAAAAAAAKogcAcAAAAAAAAA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QeAOAAAAAAAAAAAAAEAVBO4AAAAAAAAAAAAAAFRB4A4AAAAAAAAAAAAAQBUE7gAAAAAAAAAAAAAAVEHgDgAAAAAAAAAAAABAFQTuAAAAAAAAAAAAAABUQeAOAAAAAAAAAAAAAEAVBO4AAAAAAAAAAAAAAFRB4A4AAAAAAAAAAAAAQBUE7gAAAAAAAAAAAAAAVEHgDgAAAAAAAAAAAABAFQTuAAAAAAAAAAAAAABUQeAOAAAAAAAAAAAAAEAVBO4AAAAAAAAAAAAAAFRB4A4AAAAAAAAAAAAAQBUE7gAAAAAAAAAAAAAAVEHgDgAAAAAAAAAAAABAFQTuAAAAAAAAAAAAAABUQeAOAAAAAAAAAAAAAEAVBO4AAAAAAAAAAAAAAFRB4A4AAAAAAAAAAAAAQBUE7gAAAAAAAAAAAAAAVEHgDgAAAAAAAAAAAABAFQTuAAAAAAAAAAAAAABUQeAOAAAAAAAAAAAAAEAVBO4AAAAAAAAAAAAAAFRB4A4AAAAAAAAAAAAAQBUE7gAAAAAAAAAAAAAAVEHgDgAAAAAAAAAAAABAFQTuAAAAAAAAAAAAAABUQeAOAAAAAAAAAAAAAEAVBO4AAAAAAAAAAAAAAFRB4A4AAAAAAAAAAAAAQBUE7gAAAAAAAAAAAAAAVEHgDgAAAAAAAAAAAABAFQTuAAAAAAAAAAAAAABUQeAOAAAAAAAAAAAAAEAVBO4AAAAAAAAAAAAAAFRB4A4AAAAAAAAAAAAAQBUE7gAAAAAAAAAAAAAAVEHgDgAAAAAAAAAAAABAFQTuAAAAAAAAAAAAAABUQeAOAAAAAAAAAAAAAEAVBO4AAAAAAAAAAAAAAFRB4A4AAAAAAAAAAAAAQBUE7gAAAAAAAAAAAAAAVEHgDgAAAAAAAAAAAABAFQTuAAAAAAAAAAAAAABUQeAOAAAAAAAAAAAAAEAVBO4AAAAAAAAAAAAAAFRB4A4AAAAAAAAAAAAAQBUE7gAAAAAAAAAAAAAAVEHgDgAAAAAAAAAAAABAFQTuAAAAAAAAAAAAAABUQeAOAAAAAAAAAAAAAEAVBO4AAAAAAAAAAAAAAFRB4A4AAAAAAAAAAAAAQBUE7gAAAAAAAAAAAAAAVEHgDgAAAAAAAAAAAABAFQTuAAAAAAAAAAAAAABUQeAOAAAAAAAAAAAAAEAVBO4AAAAAAAAAAAAAAFRB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xm/8xor3/vmf/7lv+wQAAAAAAAAAAABY7wTuwAXvhz/84YrXv/7rv56dO3ee07Uf+9jHVrzev39/T/cGAAAAAAAAAAAAcCERuAMXvMnJyRWv3/SmN53ztbt27Vrx+ujRoz3bFwAAAAAAAAAAAMCFRuAOXPA2b9684vXU1NQ5X/vSz15yySU92xcAAAAAAAAAAADAhUbgDlzw3vGOd6x4/dhjj2V+fv6crv3+97+/4vWv/dqv9XRvAAAAAAAAAAAAABcSgTtwwXvXu96VXbt2nXn97LPP5h//8R9/4XWTk5P5u7/7uzOvW61W7rjjjr7tEwAAAAAAAAAAAGC9E7gDF7x2u50//dM/XfHeJz/5yfzbv/3bK17z3HPP5YYbbshPf/rTM+99+tOfzlVXXdXXvQIAAAAAAAAAAACsZ8OD3gBADW655Zb8z//8T+65556F1ydPnsz111+f973vfbnxxhuzZ8+ejIyM5IUXXsgjjzySr33tazl16tSZ6z/xiU/kS1/60gB/AgAAAAAAAAAAAIC1T+AOsOjP/uzPsnfv3tx55515+umnF977zne+s/D1St7+9rfn85//fG6++eae7+fFF1/MT37yk9d0zf79+1e8np2dXfgCfrG5ubl0Op0VrwEGwf0IqIX7EVAL9yOgJu5JQC3cj4BauB8BtXA/enX6IWCtEbgDLPPxj388H/zgB/O5z30uX/nKV171s29729vye7/3e/noRz/al718+ctfzhe/+MXXtcaxY8dy+PDhnu0J1rPyh9sTJ06ceT0/P5/hYf+pBKw+9yOgFu5HQC3cj4CauCcBtXA/AmrhfgTUwv3oFzdEAGvJ0KA3AFDTf+j+yZ/8SXbv3v0L4/biBz/4QW677baFz//Lv/zLquwRAAAAAAAAAAAAYD0TuAMD9dnPfjatVqvvX1/4whdedR/Hjx/Pe9/73nz+85/P0aNHF9677LLL8ud//ud54oknFr5/+vTpPPPMM/na176W973vfWeufe655/KRj3wkf/3Xf933/70AAAAAAAAAAAAA1jP/BgdwwSv/JNHHPvaxPProo2fe+/CHP5yvfvWr2bRp04rPvulNb1r4+vjHP56/+Zu/yac+9amF64vPfOYzeetb37oifn89yto333zza7pm//79uemmm8683rx5c7Zt29aT/cCF8K84lL8Qs2RiYsI/VwYM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rOc3RgJy6Y96yxgJKBfjI6gPq8OEm3IWSEgV619++eWatQdYve+HjI+AXCbc9IbxEUDPCbgDAH3WZz7zmfjxj39csu/iiy+OI488supt2W677Va52mC6ub3rrrtWeD4gfzn1Sb3ROUw2evTomrUFqP0Ly97qPKa5++67i7FPd91xxx0rPB/Qd5W7P+qN1G/NmjWrZJ8xElCLZ0iJ8RGQ61jNBEDouyr9zNj4COgLBQiMjwB6ru+scwYA0MHpp58eF110Ucm+c889Nz71qU/VpD0HHHDAMg/f5s+fXyxl350Hb//617/at8ePH198gNVHbn1Sb9x+++0rrDgB9C1PP/10yfZ6661X1vOnilmpKvPjjz9ebKfxURonTZw4caXHpu/+9a9/bd9O1Qrf+c53lrV9QP30R73xt7/9rWRyTmNjY6y//vo1bRPQtbR61hve8IYeH3fKKafEgw8+2L79uc99Lvbbb7/27XXXXbdsbdxzzz2L50VprJM89thjRR+4ySabrPTYp556qljmvs3QoUOL8wHUOuya7tdGjRpVs/YAlTN9+vRl7tfK/czY+AjoC0WajI8Aek7AHQDoc84///z4yle+UrLvtNNOKz61kh7mbb/99vH3v/+92H711VfjF7/4RbGE7Mp0rvh80EEHVaydQH30SasqBbcuu+yykn177713zdoDVFZLS0v89re/Ldm3zTbblP06Bx54YHzjG98oGft0J+D+85//vBhTtdlpp51izJgxZW8fUD/90arqfM+2yy67xJprrlmz9gArfj6zKoGrESNGlGy//vWvj3322ScqYdCgQUV4/tprr23f95Of/CTOPvvslR6bvtfR/vvvHwMHDqxIO4G+P+GmnAUSNthgg2ISIND3dL4fSmOtLbfcsqzXMD4Ccplw0xvGRwA9p5cEAPqUH/zgB3HqqaeW7EsVklOl5Fo7+uijS6o1/9d//Vd86EMfKh7MLc/DDz9chLfaNDQ0xJFHHlnxtgJ9v09aFanfmjp1ask+k26g77r00kvjkUceWSaMXm5HHXVUfPOb3ywCrMlVV10Vn//85+N1r3vdco9ZuHBh0Sd1HmsBfVO1+qNVccstt8Tll19esu/ggw+uWXuAviGNazoGuL7zne8U95Irqj74wgsvxHe/+91lzgPkaXWYcFPOwKsCCdA3pXdYX//616tyP2R8BOQw4aY3jI8Aeq5hFY4BAMjSz372szj++ONL9qUK6RdffHHZr5VC5mnZsLZPd0LnxxxzTGy88cbt22kJxc985jPtYa7O5s6dG4cffngsXry4fd+hhx5avLQA8pdzn/S9730vbrrpph5d48ILL4wzzjhjmWDZjjvuuEptBqpj8uTJcd5558W//vWvHh33y1/+Mo477riSfe9///tXuvTzT3/605L+aNNNN13ptVLVwg984APt22nsc8QRRxRjoa6ksdNJJ51Usrz05ptvXgTlgXzl3h/96U9/KoL0acWa7krjqfe85z3R1NRUUn3r2GOP7fY5gL7vrLPOKumP9txzz5Uec8ABB8TOO+/cvj1r1qwijLVkyZIuv5/GT+nv6Xttdt9993j7299epv8KgO674oorikmAHZkACHm7//77i9X1enK/lo5J1dDnzZvXvm/w4MFF0YKVMT4CVucJN6vC+Ahg1ajgDgBUzR133BELFixYZv8DDzywTEXOP//5z12eY8yYMV0GvNP3UxCqubm5fd+ECRPikEMOiRtvvLHHVXAqEdhMSx6mSqMppN7m+9//frz00ktFNeeOM8hTUCKF3zsuN7vWWmvFl770pbK3C+pVPfdJd955ZxG+33bbbYtQaXoRsfXWW8caa6xR8r30QiO194ILLohbb7215G+jRo0qQu9A3v3Ryy+/HJMmTYqvfvWrRQjz3e9+d7zpTW+K9dZbb5nvpheSN998c7H6xO9///uSv40cOXKZFwTl9JWvfCV+85vftL9Ivfvuu2PixIlFZfeOLznTBMHTTjstrrnmmpLj0xhrwIABFWsf1It67o9mzJhRTJQ5/fTTiwB9msi3ww47xLBhw0q+l8Ls99xzT1EFML2c7DjeSytupSqCa665ZtnbB/Wmkv3R6uL888+PPfbYo72fSWOl/fbbr+gDU//U5t57741TTjmlmEjUpn///sWkIoDOgdKzzz67fTv1MZ2DVh2l1bXSM+00bksB1O74n//5n/jYxz5Wsm+77bYrzgHkOz6aM2dOnHzyyXHOOeeU3K+ts846yxQd+L//+7/40Y9+FD/84Q9j0aJFJX9P93vpGpVifAR9X5o8k54JfeITn+j285V0TFpteFUn3BgfAeRLwB0AqJoPf/jD8fTTT6/0e88//3zsu+++Xf4tBUZTJb7Obr/99mUq7aUl7FNos6dW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AAAAAAAAQBYE3AEAAAAAAAAAAAAAyIKAOwAAAAAAAAAAAAAAWRBwBwAAAAAAAAAAAAAgCwLuAAAAAAAAAAAAAABkQcAdAAAAAAAAAAAAAIAsCLgDAAAAAAAAAAAAAJAFAXcAAAAAAAAAAAAAALIg4A4AAAAAAAAAAAAAQBYE3AEAAAAAAAAAAAAAyIKAOwAAAAAAAAAAAAAAWRBwBwAAAAAAAAAAAAAgCwLuAAAAAAAAAAAAAABkQcAdAAAAAAAAAAAAAIAsCLgDAAAAAAAAAAAAAJAFAXcAAAAAAAAAAAAAALIg4A4AAAAAAAAAAAAAQBYE3AEAAAAAAAAAAAAAyIKAOwAAAAAAAAAAAAAAWRBwBwAAAAAAAAAAAAAgCwLuAAAAAAAAAAAAAABkQcAdAAAAAAAAAAAAAIAsCLgDAAAAAAAAAAAAAJAFAXcAAAAAAAAAAAAAALIg4A4AAAAAAAAAAAAAQBYE3AEAAAAAAAAAAAAAyIKAOwAAAAAAAAAAAAAAWRBwBwAAAAAAAAAAAAAgCwLuAAAAAAAAAAAAAABkQcAdAAAAAAAAAAAAAIAsCLgDAAAAAAAAAAAAAJAFAXcAAAAAAAAAAAAAALIg4A4AAAAAAAAAAAAAQBYE3AEAAAAAAAAAAAAAyIKAOwAAAAAAAAAAAAAAWRBwBwAAAAAAAAAAAAAgCwLuAAAAAAAAAAAAAABkQcAdAAAAAAAAAAAAAIAsCLgDAAAAAAAAAAAAAJAFAXcAAAAAAAAAAAAAALIg4A4AAAAAAAAAAAAAQBYE3AEAAAAAAAAAAAAAyIKAOwAAAAAAAAAAAAAAWRBwBwAAAAAAAAAAAAAgCwLuAAAAAAAAAAAAAABkQcAdAAAAAAAAAAAAAIAsCLgDAAAAAAAAAAAAAJAFAXcAAAAAAAAAAAAAALIg4A4AAAAAAAAAAAAAQBYE3AEAAAAAAAAAAAAAyIKAOwAAAAAAAAAAAAAAWRBwBwAAAAAAAAAAAAAgCwLuAAAAAAAAAAAAAABkQcAdAAAAAAAAAAAAAIAsCLgDAAAAAAAAAAAAAJAFAXcAAAAAAAAAAAAAALIg4A4AAAAAAAAAAAAAQBYE3AEAAAAAAAAAAAAAyIKAOwAAAAAAAAAAAAAAWRBwBwAAAAAAAAAAAAAgCwLuAAAAAAAAAAAAAABkQcAdAAAAAAAAAAAAAIAsCLgDAAAAAAAAAAAAAJAFAXcAAAAAAAAAAAAAALIg4A4AAAAAAAAAAAAAQBYE3AEAAAAAAAAAAAAAyIKAOwAAAAAAAAAAAAAAWRBwBwAAAAAAAAAAAAAgCwLuAAAAAAAAAAAAAABkQcAdAAAAAAAAAAAAAIAsCLgDAAAAAAAAAAAAAJAFAXcAAAAAAAAAAAAAALIg4A4AAAAAAAAAAAAAQBYE3AEAAAAAAAAAAAAAyIKAOwAAAAAAAAAAAAAAWRBwBwAAAAAAAAAAAAAgCwLuAAAAAAAAAAAAAABkQcAdAAAAAAAAAAAAAIAsCLgDAAAAAAAAAAAAAJAFAXcAAAAAAAAAAAAAALIg4A4AAAAAAAAAAAAAQBYE3AEAAAAAAAAAAAAAyIKAOwAAAAAAAAAAAAAAWRBwBwAAAAAAAAAAAAAgCwLuAAAAAAAAAAAAAABkQcAdAAAAAAAAAAAAAIAsCLgDAAAAAAAAAAAAAJAFAXcAAAAAAAAAAAAAALIg4A4AAAAAAAAAAAAAQBYE3AEAAAAAAAAAAAAAyIKAOwAAAAAAAAAAAAAAWRBwBwAAAAAAAAAAAAAgCwLuAAAAAAAAAAAAAABkQcAdAAAAAAAAAAAAAIAsCLgDAAAAAAAAAAAAAJAFAXcAAAAAAAAAAAAAALIg4A4AAAAAAAAAAAAAQBYE3AEAAAAAAAAAAAAAyIKAOwAAAAAAAAAAAAAAWRBwBwAAAAAAAAAAAAAgCwLuAAAAAAAAAAAAAABkQcAdAAAAAAAAAAAAAIAsCLgDAAAAAAAAAAAAAJAFAXcAAAAAAAAAAAAAALIg4A4AAAAAAAAAAAAAQBYE3AEAAAAAAAAAAAAAyIKAOwAAAAAAAAAAAAAAWRBwBwAAAAAAAAAAAAAgCwLuAAAAAAAAAAAAAABkQcAdAAAAAAAAAAAAAIAsCLgDAAAAAAAAAAAAAJAFAXcAAAAAAAAAAAAAALIg4A4AAAAAAAAAAAAAQBYE3AEAAAAAAAAAAAAAyIKAOwAAAAAAAAAAAAAAWRBwBwAAAAAAAAAAAAAgCwLuAAAAAAAAAAAAAABkQcAdAAAAAAAAAAAAAIAsCLgDAAAAAAAAAAAAAJAFAXcAAAAAAAAAAAAAALIg4A4AAAAAAAAAAAAAQBYE3AEAAAAAAAAAAAAAyIKAOwAAAAAAAAAAAAAAWRBwBwAAAAAAAAAAAAAgCwLuAAAAAAAAAAAAAABkQcAdAAAAAAAAAAAAAIAsCLgDAAAAAAAAAAAAAJAFAXcAAAAAAAAAAAAAALIg4A4AAAAAAAAAAAAAQBYE3AEAAAAAAAAAAAAAyIKAOwAAAAAAAAAAAAAAWRBwBwAAAAAAAAAAAAAgCwLuAAAAAAAAAAAAAABkQcAdAAAAAAAAAAAAAIAsCLgDAAAAAAAAAAAAAJAFAXcAAAAAAAAAAAAAALIg4A4AAAAAAAAAAAAAQBYE3AEAAAAAAAAAAAAAyIKAOwAAAAAAAAAAAAAAWRBwBwAAAAAAAAAAAAAgCwLuAAAAAAAAAAAAAABkQcAdAAAAAAAAAAAAAIAsCLgDAAAAAAAAAAAAAJAFAXcAAAAAAAAAAAAAALIg4A4AAAAAAAAAAAAAQBYE3AEAAAAAAAAAAAAAyIKAOwAAAAAAAAAAAAAAWRBwBwAAAAAAAAAAAAAgCwLuAAAAAAAAAAAAAABkQcAdAAAAAAAAAAAAAIAsCLgDAAAAAAAAAAAAAJAFAXcAAAAAAAAAAAAAALIg4A4AAAAAAAAAAAAAQBYE3AEAAAAAAAAAAAAAyIKAOwAAAAAAAAAAAAAAWRBwBwAAAAAAAAAAAAAgCwLuAAAAAAAAAAAAAABkQcAdAAAAAAAAAAAAAIAsCLgDAAAAAAAAAAAAAJAFAXcAAAAAAAAAAAAAALIg4A4AAAAAAAAAAAAAQBYE3AEAAAAAAAAAAAAAyIKAOwAAAAAAAAAAAAAAWRBwBwAAAAAAAAAAAAAgCwLuAAAAAAAAAAAAAABkQcAdAAAAAAAAAAAAAIDIwf8DEIHm/h3Ze3UAAAAASUVORK5CYII=",
            "num_clusters": 1,
            "method": "dbscan",
            "params": {
                "dbscan": {
                    "eps": 0.2,
                    "min_samples": 2
                },
                "kmeans": {
                    "n_clusters": 4
                },
                "hdbscan": {
                    "min_cluster_size": 2,
                    "min_samples": 1
                }
            }
        },
        "weights": {
            "token": {
                "lcs": 0.15,
                "sequence_matcher": 0.15,
                "ngram": 0.2,
                "levenshtein": 0.2,
                "tfidf_cosine": 0.2,
                "winnowing": 0.1
            },
            "combined": {
                "token": 0.6,
                "ml": 0.4
            }
        }
    }
}